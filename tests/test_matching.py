"""
Tests for matching logic

Generated By: Claude Code (Claude Sonnet 4.5)
"""

import unittest
from pathlib import Path
from unittest.mock import patch

from ap_common.constants import (
    NORMALIZED_HEADER_FILENAME,
    NORMALIZED_HEADER_CAMERA,
    NORMALIZED_HEADER_GAIN,
    NORMALIZED_HEADER_OFFSET,
    NORMALIZED_HEADER_SETTEMP,
    NORMALIZED_HEADER_READOUTMODE,
    NORMALIZED_HEADER_EXPOSURESECONDS,
    NORMALIZED_HEADER_DATE,
    NORMALIZED_HEADER_FILTER,
    NORMALIZED_HEADER_OPTIC,
    NORMALIZED_HEADER_FOCALLEN,
    TYPE_MASTER_DARK,
    TYPE_MASTER_BIAS,
    TYPE_MASTER_FLAT,
)

from ap_copy_master_to_blink.matching import (
    find_matching_dark,
    find_matching_bias,
    find_matching_flat,
    determine_required_masters,
)


class TestMatching(unittest.TestCase):
    """Test matching logic."""

    def setUp(self):
        """Set up test fixtures."""
        self.library_dir = Path("/test/library")
        self.light_metadata = {
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: "100",
            NORMALIZED_HEADER_OFFSET: "50",
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILTER: "Ha",
            NORMALIZED_HEADER_DATE: "2024-01-15",
            NORMALIZED_HEADER_OPTIC: "RedCat51",
            NORMALIZED_HEADER_FOCALLEN: "250",
        }

    @patch("ap_copy_master_to_blink.matching.find_darks_util")
    def test_find_matching_dark_exact_exposure(self, mock_find_darks):
        """Test finding dark with exact exposure match."""
        mock_find_darks.return_value = [
            {
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILENAME: "/test/library/dark_300s.xisf",
            }
        ]

        result = find_matching_dark(self.library_dir, self.light_metadata)

        self.assertIsNotNone(result)
        self.assertEqual(result[NORMALIZED_HEADER_EXPOSURESECONDS], "300")

    @patch("ap_copy_master_to_blink.matching.find_darks_util")
    def test_find_matching_dark_shorter_exposure(self, mock_find_darks):
        """Test finding dark with shorter exposure when bias allowed."""
        # Utility returns sorted list (longest first)
        mock_find_darks.return_value = [
            {
                NORMALIZED_HEADER_EXPOSURESECONDS: "120",
                NORMALIZED_HEADER_FILENAME: "/test/library/dark_120s.xisf",
            },
            {
                NORMALIZED_HEADER_EXPOSURESECONDS: "60",
                NORMALIZED_HEADER_FILENAME: "/test/library/dark_60s.xisf",
            },
        ]

        result = find_matching_dark(
            self.library_dir, self.light_metadata, allow_bias=True
        )

        self.assertIsNotNone(result)
        # Should pick longest dark < 300s (120s)
        self.assertEqual(result[NORMALIZED_HEADER_EXPOSURESECONDS], "120")

    @patch("ap_copy_master_to_blink.matching.find_darks_util")
    def test_find_matching_dark_no_match(self, mock_find_darks):
        """Test when no matching dark found."""
        mock_find_darks.return_value = []

        result = find_matching_dark(self.library_dir, self.light_metadata)

        self.assertIsNone(result)

    @patch("ap_copy_master_to_blink.matching.find_bias_util")
    def test_find_matching_bias(self, mock_find_bias):
        """Test finding matching bias."""
        mock_find_bias.return_value = [
            {NORMALIZED_HEADER_FILENAME: "/test/library/bias.xisf"}
        ]

        result = find_matching_bias(self.library_dir, self.light_metadata)

        self.assertIsNotNone(result)
        self.assertEqual(result[NORMALIZED_HEADER_FILENAME], "/test/library/bias.xisf")

    @patch("ap_copy_master_to_blink.matching.find_bias_util")
    def test_find_matching_bias_no_match(self, mock_find_bias):
        """Test when no matching bias found."""
        mock_find_bias.return_value = []

        result = find_matching_bias(self.library_dir, self.light_metadata)

        self.assertIsNone(result)

    @patch("ap_copy_master_to_blink.matching.find_flats_util")
    def test_find_matching_flat(self, mock_find_flats):
        """Test finding matching flat."""
        mock_find_flats.return_value = [
            {NORMALIZED_HEADER_FILENAME: "/test/library/flat_ha.xisf"}
        ]

        result = find_matching_flat(self.library_dir, self.light_metadata)

        self.assertIsNotNone(result)
        self.assertEqual(
            result[NORMALIZED_HEADER_FILENAME], "/test/library/flat_ha.xisf"
        )

    @patch("ap_copy_master_to_blink.matching.find_flats_util")
    def test_find_matching_flat_no_match(self, mock_find_flats):
        """Test when no matching flat found."""
        mock_find_flats.return_value = []

        result = find_matching_flat(self.library_dir, self.light_metadata)

        self.assertIsNone(result)

    @patch("ap_copy_master_to_blink.matching.find_matching_dark")
    @patch("ap_copy_master_to_blink.matching.find_matching_bias")
    @patch("ap_copy_master_to_blink.matching.find_matching_flat")
    def test_determine_required_masters_exact_dark(
        self, mock_flat, mock_bias, mock_dark
    ):
        """Test determining required masters with exact dark match."""
        mock_dark.return_value = {
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILENAME: "/test/dark.xisf",
        }
        mock_flat.return_value = {NORMALIZED_HEADER_FILENAME: "/test/flat.xisf"}

        masters = determine_required_masters(self.library_dir, self.light_metadata)

        self.assertIsNotNone(masters[TYPE_MASTER_DARK])
        self.assertIsNone(
            masters[TYPE_MASTER_BIAS]
        )  # No bias needed for exact exposure match
        self.assertIsNotNone(masters[TYPE_MASTER_FLAT])

    @patch("ap_copy_master_to_blink.matching.find_matching_dark")
    @patch("ap_copy_master_to_blink.matching.find_matching_bias")
    @patch("ap_copy_master_to_blink.matching.find_matching_flat")
    def test_determine_required_masters_shorter_dark_with_bias(
        self, mock_flat, mock_bias, mock_dark
    ):
        """Test determining required masters with shorter dark and bias."""
        mock_dark.return_value = {
            NORMALIZED_HEADER_EXPOSURESECONDS: "120",
            NORMALIZED_HEADER_FILENAME: "/test/dark.xisf",
        }
        mock_bias.return_value = {NORMALIZED_HEADER_FILENAME: "/test/bias.xisf"}
        mock_flat.return_value = {NORMALIZED_HEADER_FILENAME: "/test/flat.xisf"}

        masters = determine_required_masters(self.library_dir, self.light_metadata)

        self.assertIsNotNone(masters[TYPE_MASTER_DARK])
        self.assertIsNotNone(
            masters[TYPE_MASTER_BIAS]
        )  # Bias needed for exposure mismatch
        self.assertIsNotNone(masters[TYPE_MASTER_FLAT])

    @patch("ap_copy_master_to_blink.matching.find_matching_dark")
    @patch("ap_copy_master_to_blink.matching.find_matching_bias")
    @patch("ap_copy_master_to_blink.matching.find_matching_flat")
    def test_determine_required_masters_shorter_dark_no_bias(
        self, mock_flat, mock_bias, mock_dark
    ):
        """Test determining required masters with shorter dark but no bias."""
        mock_dark.return_value = {
            NORMALIZED_HEADER_EXPOSURESECONDS: "120",
            NORMALIZED_HEADER_FILENAME: "/test/dark.xisf",
        }
        mock_bias.return_value = None  # No bias found
        mock_flat.return_value = {NORMALIZED_HEADER_FILENAME: "/test/flat.xisf"}

        masters = determine_required_masters(self.library_dir, self.light_metadata)

        # Should reject dark without bias
        self.assertIsNone(masters[TYPE_MASTER_DARK])
        self.assertIsNone(masters[TYPE_MASTER_BIAS])
        self.assertIsNotNone(masters[TYPE_MASTER_FLAT])

    @patch("ap_copy_master_to_blink.matching.find_darks_util")
    def test_find_matching_dark_none_filter_normalized(self, mock_find_darks):
        """Test that None filter is normalized to empty string in filter criteria."""
        # Light with None filter
        light_with_none_filter = self.light_metadata.copy()
        light_with_none_filter[NORMALIZED_HEADER_FILTER] = None

        mock_find_darks.return_value = [
            {
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILENAME: "/test/library/dark_300s.xisf",
            }
        ]

        result = find_matching_dark(self.library_dir, light_with_none_filter)

        # None values are handled by ap_common utilities
        self.assertIsNotNone(result)

    @patch("ap_copy_master_to_blink.matching.find_flats_util")
    def test_find_matching_flat_none_filter_normalized(self, mock_find_flats):
        """Test that None filter is normalized to empty string for flat matching."""
        # Light with None filter
        light_with_none_filter = self.light_metadata.copy()
        light_with_none_filter[NORMALIZED_HEADER_FILTER] = None

        mock_find_flats.return_value = [
            {NORMALIZED_HEADER_FILENAME: "/test/library/flat_nofilter.xisf"}
        ]

        result = find_matching_flat(self.library_dir, light_with_none_filter)

        # None values are handled by ap_common utilities
        # Verify result was found
        self.assertIsNotNone(result)
        self.assertEqual(
            result[NORMALIZED_HEADER_FILENAME], "/test/library/flat_nofilter.xisf"
        )

    @patch("ap_copy_master_to_blink.matching.find_bias_util")
    def test_find_matching_bias_none_values_normalized(self, mock_find_bias):
        """Test that None values in multiple fields are normalized to empty string."""
        # Light with multiple None values
        light_with_nones = {
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: None,  # None value
            NORMALIZED_HEADER_OFFSET: None,  # None value
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
        }

        mock_find_bias.return_value = [
            {NORMALIZED_HEADER_FILENAME: "/test/library/bias.xisf"}
        ]

        _ = find_matching_bias(self.library_dir, light_with_nones)

        # Verify utility was called - None values are handled by ap_common utilities
        self.assertTrue(mock_find_bias.called)

    @patch("ap_copy_master_to_blink.matching.find_darks_util")
    def test_find_matching_dark_missing_readoutmode(self, mock_find_darks):
        """Test that missing readoutmode (None) is filtered out from criteria.

        Different cameras have different metadata - DSLRs don't have readoutmode,
        gain, or offset. Verify None values are removed before filtering.
        """
        # Light metadata missing readoutmode (e.g., DSLR)
        light_without_readout = {
            NORMALIZED_HEADER_CAMERA: "Canon EOS",
            NORMALIZED_HEADER_GAIN: None,  # DSLRs don't have gain
            NORMALIZED_HEADER_OFFSET: None,  # DSLRs don't have offset
            NORMALIZED_HEADER_SETTEMP: None,  # DSLRs don't have temp control
            NORMALIZED_HEADER_READOUTMODE: None,  # DSLRs don't have readoutmode
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
        }

        mock_find_darks.return_value = [
            {
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILENAME: "/test/library/dark_300s.xisf",
            }
        ]

        result = find_matching_dark(self.library_dir, light_without_readout)

        # None values are handled by ap_common utilities (build_normalized_filters)
        # Verify utility was called
        self.assertTrue(mock_find_darks.called)

        # Result should still be found
        self.assertIsNotNone(result)


class TestLibraryProfileFromPath(unittest.TestCase):
    """
    Regression tests for library search profileFromPath parameter.

    Background:
    -----------
    The library uses directory structure:
    _Library/{frame_type}/{camera}/{optic}/DATE_{date}/
    Unlike blink directories (which use
    {optic}@f{ratio}+{camera} format), library directories
    use bare equipment names without KEY_VALUE encoding
    (e.g., "ATR585M/SQA55" not "CAMERA_ATR585M").

    When profileFromPath=True (default), ap_common attempts
    to extract metadata from path structure. This works for
    blink directories but FAILS for library directories:
    1. Bare directory names (ATR585M, SQA55) are not recognized as KEY_VALUE pairs
    2. Camera and optic metadata are missing from extracted profile
    3. Matching fails even when correct calibration frames exist

    Fix:
    ----
    Library searches MUST use profileFromPath=False to read
    actual FITS headers from files instead of attempting to
    parse library directory structure.

    Critical Comment Reference:
    ---------------------------
    ap_common/calibration.py lines 86-87:
        # IMPORTANT: profileFromPath only works with blink/data directory structure
        # For library searches, it should typically be False to read actual file headers

    Regression Test Strategy:
    -------------------------
    These tests verify that matching.py functions explicitly pass profileFromPath=False
    when calling ap_common calibration utilities. The tests use mocks to inspect the
    actual function call arguments, ensuring the parameter is set correctly.

    To verify this test catches the regression:
    1. Comment out profileFromPath=False in matching.py
    2. Run: pytest tests/test_matching.py::TestLibraryProfileFromPath -v
    3. Tests should FAIL with assertion about missing profileFromPath parameter
    4. Restore profileFromPath=False
    5. Tests should PASS
    """

    def setUp(self):
        """Set up test fixtures."""
        self.library_dir = Path("/test/library")
        self.light_metadata = {
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: "100",
            NORMALIZED_HEADER_OFFSET: "50",
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILTER: "Ha",
            NORMALIZED_HEADER_DATE: "2024-01-15",
            NORMALIZED_HEADER_OPTIC: "RedCat51",
            NORMALIZED_HEADER_FOCALLEN: "250",
        }

    @patch("ap_copy_master_to_blink.matching.find_darks_util")
    def test_find_matching_dark_uses_profileFromPath_false(self, mock_find_darks):
        """
        Verify find_matching_dark() passes profileFromPath=False to library search.

        Regression: Without profileFromPath=False, library searches fail because
        bare directory names (e.g., "ATR585M") are not recognized as KEY_VALUE pairs,
        causing camera/optic metadata to be missing from the extracted profile.
        """
        mock_find_darks.return_value = []

        find_matching_dark(self.library_dir, self.light_metadata)

        # Verify the function was called with profileFromPath=False
        mock_find_darks.assert_called_once()
        call_kwargs = mock_find_darks.call_args[1]
        self.assertIn(
            "profileFromPath",
            call_kwargs,
            "find_darks_util must be called with explicit profileFromPath parameter",
        )
        self.assertFalse(
            call_kwargs["profileFromPath"],
            "Library searches must use profileFromPath=False to read file headers",
        )

    @patch("ap_copy_master_to_blink.matching.find_bias_util")
    def test_find_matching_bias_uses_profileFromPath_false(self, mock_find_bias):
        """
        Verify find_matching_bias() passes profileFromPath=False to library search.

        Regression: Without profileFromPath=False, library searches fail because
        bare directory names (e.g., "ATR585M") are not recognized as KEY_VALUE pairs,
        causing camera metadata to be missing from the extracted profile.
        """
        mock_find_bias.return_value = []

        find_matching_bias(self.library_dir, self.light_metadata)

        # Verify the function was called with profileFromPath=False
        mock_find_bias.assert_called_once()
        call_kwargs = mock_find_bias.call_args[1]
        self.assertIn(
            "profileFromPath",
            call_kwargs,
            "find_bias_util must be called with explicit profileFromPath parameter",
        )
        self.assertFalse(
            call_kwargs["profileFromPath"],
            "Library searches must use profileFromPath=False to read file headers",
        )

    @patch("ap_copy_master_to_blink.matching.find_flats_util")
    def test_find_matching_flat_uses_profileFromPath_false(self, mock_find_flats):
        """
        Verify find_matching_flat() passes
        profileFromPath=False to library search.

        Regression: Without profileFromPath=False, library
        searches fail because bare directory names (e.g.,
        "ATR585M/SQA55") are not recognized as KEY_VALUE
        pairs, causing camera/optic metadata to be missing.
        """
        mock_find_flats.return_value = []

        find_matching_flat(self.library_dir, self.light_metadata)

        # Verify the function was called with profileFromPath=False
        mock_find_flats.assert_called_once()
        call_kwargs = mock_find_flats.call_args[1]
        self.assertIn(
            "profileFromPath",
            call_kwargs,
            "find_flats_util must be called with explicit profileFromPath parameter",
        )
        self.assertFalse(
            call_kwargs["profileFromPath"],
            "Library searches must use profileFromPath=False to read file headers",
        )

    @patch("ap_copy_master_to_blink.matching.find_flats_util")
    def test_library_search_parameters_complete(self, mock_find_flats):
        """
        Verify library search includes all expected parameters.

        This test documents the complete expected function
        signature for library searches, serving as a
        reference for the correct parameter set.
        """
        mock_find_flats.return_value = []

        find_matching_flat(self.library_dir, self.light_metadata)

        # Verify all expected parameters are present
        call_kwargs = mock_find_flats.call_args[1]
        expected_params = {
            "match_fields",
            "recursive",
            "profileFromPath",
            "printStatus",
        }

        for param in expected_params:
            self.assertIn(
                param,
                call_kwargs,
                f"Library search must include {param} parameter",
            )

        # Verify specific values for library searches
        self.assertTrue(
            call_kwargs["recursive"],
            "Library searches must use recursive=True to traverse subdirectories",
        )
        self.assertFalse(
            call_kwargs["profileFromPath"],
            "Library searches must use profileFromPath=False",
        )
        self.assertFalse(
            call_kwargs["printStatus"],
            "Library searches should be silent (printStatus=False)",
        )


if __name__ == "__main__":
    unittest.main()
