"""
Tests for matching logic

Generated By: Claude Code (Claude Sonnet 4.5)
"""

import unittest
from pathlib import Path
from unittest.mock import patch, MagicMock

from ap_common.constants import (
    NORMALIZED_HEADER_CAMERA,
    NORMALIZED_HEADER_GAIN,
    NORMALIZED_HEADER_OFFSET,
    NORMALIZED_HEADER_SETTEMP,
    NORMALIZED_HEADER_READOUTMODE,
    NORMALIZED_HEADER_EXPOSURESECONDS,
    NORMALIZED_HEADER_DATE,
    NORMALIZED_HEADER_FILTER,
    NORMALIZED_HEADER_OPTIC,
    NORMALIZED_HEADER_FOCALLEN,
    TYPE_MASTER_DARK,
    TYPE_MASTER_BIAS,
    TYPE_MASTER_FLAT,
)

from ap_copy_master_to_blink.matching import (
    find_matching_dark,
    find_matching_bias,
    find_matching_flat,
    determine_required_masters,
)


class TestMatching(unittest.TestCase):
    """Test matching logic."""

    def setUp(self):
        """Set up test fixtures."""
        self.library_dir = Path("/test/library")
        self.light_metadata = {
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: "100",
            NORMALIZED_HEADER_OFFSET: "50",
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILTER: "Ha",
            NORMALIZED_HEADER_DATE: "2024-01-15",
            NORMALIZED_HEADER_OPTIC: "RedCat51",
            NORMALIZED_HEADER_FOCALLEN: "250",
        }

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_find_matching_dark_exact_exposure(self, mock_get_metadata):
        """Test finding dark with exact exposure match."""
        mock_get_metadata.return_value = [
            {
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                "filepath": "/test/library/dark_300s.xisf",
            }
        ]

        result = find_matching_dark(self.library_dir, self.light_metadata)

        self.assertIsNotNone(result)
        self.assertEqual(result[NORMALIZED_HEADER_EXPOSURESECONDS], "300")

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_find_matching_dark_shorter_exposure(self, mock_get_metadata):
        """Test finding dark with shorter exposure (no exact match)."""
        mock_get_metadata.return_value = [
            {
                NORMALIZED_HEADER_EXPOSURESECONDS: "120",
                "filepath": "/test/library/dark_120s.xisf",
            },
            {
                NORMALIZED_HEADER_EXPOSURESECONDS: "60",
                "filepath": "/test/library/dark_60s.xisf",
            },
        ]

        result = find_matching_dark(self.library_dir, self.light_metadata)

        self.assertIsNotNone(result)
        # Should pick longest dark < 300s (120s)
        self.assertEqual(result[NORMALIZED_HEADER_EXPOSURESECONDS], "120")

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_find_matching_dark_no_match(self, mock_get_metadata):
        """Test when no matching dark found."""
        mock_get_metadata.return_value = []

        result = find_matching_dark(self.library_dir, self.light_metadata)

        self.assertIsNone(result)

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_find_matching_bias(self, mock_get_metadata):
        """Test finding matching bias."""
        mock_get_metadata.return_value = [{"filepath": "/test/library/bias.xisf"}]

        result = find_matching_bias(self.library_dir, self.light_metadata)

        self.assertIsNotNone(result)
        self.assertEqual(result["filepath"], "/test/library/bias.xisf")

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_find_matching_bias_no_match(self, mock_get_metadata):
        """Test when no matching bias found."""
        mock_get_metadata.return_value = []

        result = find_matching_bias(self.library_dir, self.light_metadata)

        self.assertIsNone(result)

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_find_matching_flat(self, mock_get_metadata):
        """Test finding matching flat."""
        mock_get_metadata.return_value = [{"filepath": "/test/library/flat_ha.xisf"}]

        result = find_matching_flat(self.library_dir, self.light_metadata)

        self.assertIsNotNone(result)
        self.assertEqual(result["filepath"], "/test/library/flat_ha.xisf")

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_find_matching_flat_no_match(self, mock_get_metadata):
        """Test when no matching flat found."""
        mock_get_metadata.return_value = []

        result = find_matching_flat(self.library_dir, self.light_metadata)

        self.assertIsNone(result)

    @patch("ap_copy_master_to_blink.matching.find_matching_dark")
    @patch("ap_copy_master_to_blink.matching.find_matching_bias")
    @patch("ap_copy_master_to_blink.matching.find_matching_flat")
    def test_determine_required_masters_exact_dark(
        self, mock_flat, mock_bias, mock_dark
    ):
        """Test determining required masters with exact dark match."""
        mock_dark.return_value = {
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            "filepath": "/test/dark.xisf",
        }
        mock_flat.return_value = {"filepath": "/test/flat.xisf"}

        masters = determine_required_masters(self.library_dir, self.light_metadata)

        self.assertIsNotNone(masters[TYPE_MASTER_DARK])
        self.assertIsNone(
            masters[TYPE_MASTER_BIAS]
        )  # No bias needed for exact exposure match
        self.assertIsNotNone(masters[TYPE_MASTER_FLAT])

    @patch("ap_copy_master_to_blink.matching.find_matching_dark")
    @patch("ap_copy_master_to_blink.matching.find_matching_bias")
    @patch("ap_copy_master_to_blink.matching.find_matching_flat")
    def test_determine_required_masters_shorter_dark_with_bias(
        self, mock_flat, mock_bias, mock_dark
    ):
        """Test determining required masters with shorter dark and bias."""
        mock_dark.return_value = {
            NORMALIZED_HEADER_EXPOSURESECONDS: "120",
            "filepath": "/test/dark.xisf",
        }
        mock_bias.return_value = {"filepath": "/test/bias.xisf"}
        mock_flat.return_value = {"filepath": "/test/flat.xisf"}

        masters = determine_required_masters(self.library_dir, self.light_metadata)

        self.assertIsNotNone(masters[TYPE_MASTER_DARK])
        self.assertIsNotNone(
            masters[TYPE_MASTER_BIAS]
        )  # Bias needed for exposure mismatch
        self.assertIsNotNone(masters[TYPE_MASTER_FLAT])

    @patch("ap_copy_master_to_blink.matching.find_matching_dark")
    @patch("ap_copy_master_to_blink.matching.find_matching_bias")
    @patch("ap_copy_master_to_blink.matching.find_matching_flat")
    def test_determine_required_masters_shorter_dark_no_bias(
        self, mock_flat, mock_bias, mock_dark
    ):
        """Test determining required masters with shorter dark but no bias."""
        mock_dark.return_value = {
            NORMALIZED_HEADER_EXPOSURESECONDS: "120",
            "filepath": "/test/dark.xisf",
        }
        mock_bias.return_value = None  # No bias found
        mock_flat.return_value = {"filepath": "/test/flat.xisf"}

        masters = determine_required_masters(self.library_dir, self.light_metadata)

        # Should reject dark without bias
        self.assertIsNone(masters[TYPE_MASTER_DARK])
        self.assertIsNone(masters[TYPE_MASTER_BIAS])
        self.assertIsNotNone(masters[TYPE_MASTER_FLAT])


if __name__ == "__main__":
    unittest.main()
