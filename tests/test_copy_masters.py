"""
Tests for copy logic

Generated By: Claude Code (Claude Sonnet 4.5)
"""

import unittest
from pathlib import Path
from unittest.mock import patch, MagicMock
from io import StringIO

from ap_copy_master_to_blink.copy_masters import (
    get_date_directory,
    scan_blink_directories,
    group_lights_by_config,
    copy_master_to_blink,
    process_blink_directory,
)
from ap_copy_master_to_blink.__main__ import (
    validate_directories,
    print_header,
    print_summary,
)
from ap_common.constants import (
    NORMALIZED_HEADER_CAMERA,
    NORMALIZED_HEADER_GAIN,
    NORMALIZED_HEADER_OFFSET,
    NORMALIZED_HEADER_SETTEMP,
    NORMALIZED_HEADER_READOUTMODE,
    NORMALIZED_HEADER_EXPOSURESECONDS,
    NORMALIZED_HEADER_FILTER,
    NORMALIZED_HEADER_DATE,
    TYPE_MASTER_DARK,
    TYPE_MASTER_BIAS,
    TYPE_MASTER_FLAT,
)


class TestCopyMasters(unittest.TestCase):
    """Test copy logic."""

    def test_get_date_directory_from_filter_dir(self):
        """Test extracting DATE directory from FILTER directory."""
        lights_dir = Path("/blink/M31/DATE_2024-01-15/FILTER_Ha")
        result = get_date_directory(lights_dir)

        self.assertEqual(result.name, "DATE_2024-01-15")

    def test_get_date_directory_from_date_dir(self):
        """Test when already in DATE directory."""
        lights_dir = Path("/blink/M31/DATE_2024-01-15")
        result = get_date_directory(lights_dir)

        self.assertEqual(result.name, "DATE_2024-01-15")

    def test_get_date_directory_search_upward(self):
        """Test searching upward for DATE directory."""
        lights_dir = Path("/blink/M31/DATE_2024-01-15/FILTER_Ha/subdir")
        result = get_date_directory(lights_dir)

        self.assertEqual(result.name, "DATE_2024-01-15")

    @patch("ap_copy_master_to_blink.copy_masters.get_filenames")
    @patch("ap_copy_master_to_blink.copy_masters.get_metadata")
    def test_scan_blink_directories(self, mock_get_metadata, mock_get_filenames):
        """Test scanning blink directories for light frames."""
        mock_get_filenames.return_value = [
            Path("/blink/light1.fits"),
            Path("/blink/light2.fits"),
        ]
        mock_get_metadata.return_value = [
            {"filepath": "/blink/light1.fits"},
            {"filepath": "/blink/light2.fits"},
        ]

        result = scan_blink_directories(Path("/blink"))

        self.assertEqual(len(result), 2)
        mock_get_filenames.assert_called_once()
        mock_get_metadata.assert_called_once()

    def test_group_lights_by_config(self):
        """Test grouping lights by calibration configuration."""
        metadata_list = [
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: "Ha",
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: "Ha",
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: "OIII",  # Different filter
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
        ]

        groups = group_lights_by_config(metadata_list)

        # Should have 2 groups (Ha and OIII)
        self.assertEqual(len(groups), 2)

        # Ha group should have 2 lights
        ha_groups = [g for g in groups.values() if len(g) == 2]
        self.assertEqual(len(ha_groups), 1)

        # OIII group should have 1 light
        oiii_groups = [g for g in groups.values() if len(g) == 1]
        self.assertEqual(len(oiii_groups), 1)

    @patch("ap_copy_master_to_blink.copy_masters.copy_file")
    def test_copy_master_to_blink_new_file(self, mock_copy_file):
        """Test copying master when file doesn't exist."""
        master_metadata = {"filepath": "/library/dark.xisf"}
        dest_dir = Path("/blink/DATE_2024-01-15")

        with patch("pathlib.Path.exists", return_value=False):
            result = copy_master_to_blink(master_metadata, dest_dir, dry_run=False)

        self.assertTrue(result)
        mock_copy_file.assert_called_once()

    def test_copy_master_to_blink_existing_file(self):
        """Test skipping copy when file already exists."""
        master_metadata = {"filepath": "/library/dark.xisf"}
        dest_dir = Path("/blink/DATE_2024-01-15")

        with patch("pathlib.Path.exists", return_value=True):
            result = copy_master_to_blink(master_metadata, dest_dir, dry_run=False)

        self.assertFalse(result)

    def test_copy_master_to_blink_dry_run(self):
        """Test dry-run mode doesn't copy files."""
        master_metadata = {"filepath": "/library/dark.xisf"}
        dest_dir = Path("/blink/DATE_2024-01-15")

        with patch("pathlib.Path.exists", return_value=False):
            with patch("ap_copy_master_to_blink.copy_masters.copy_file") as mock_copy:
                result = copy_master_to_blink(master_metadata, dest_dir, dry_run=True)

        self.assertTrue(result)
        mock_copy.assert_not_called()

    @patch("ap_copy_master_to_blink.copy_masters.scan_blink_directories")
    @patch("ap_copy_master_to_blink.copy_masters.determine_required_masters")
    @patch("ap_copy_master_to_blink.copy_masters.copy_master_to_blink")
    def test_process_blink_directory_no_lights(
        self, mock_copy, mock_determine, mock_scan
    ):
        """Test processing when no lights found."""
        mock_scan.return_value = []

        stats = process_blink_directory(Path("/library"), Path("/blink"), dry_run=False)

        self.assertEqual(stats["configs_processed"], 0)
        mock_determine.assert_not_called()
        mock_copy.assert_not_called()

    @patch("ap_copy_master_to_blink.copy_masters.scan_blink_directories")
    @patch("ap_copy_master_to_blink.copy_masters.group_lights_by_config")
    @patch("ap_copy_master_to_blink.copy_masters.determine_required_masters")
    @patch("ap_copy_master_to_blink.copy_masters.get_date_directory")
    @patch("ap_copy_master_to_blink.copy_masters.copy_master_to_blink")
    def test_process_blink_directory_with_all_masters(
        self, mock_copy, mock_get_date, mock_determine, mock_group, mock_scan
    ):
        """Test processing with all master types found."""
        # Mock light metadata
        light_metadata = {
            "filepath": "/blink/M31/DATE_2024-01-15/FILTER_Ha/light.fits",
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: "100",
            NORMALIZED_HEADER_OFFSET: "50",
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILTER: "Ha",
            NORMALIZED_HEADER_DATE: "2024-01-15",
        }

        mock_scan.return_value = [light_metadata]
        mock_group.return_value = {("config_key",): [light_metadata]}
        mock_get_date.return_value = Path("/blink/M31/DATE_2024-01-15")

        # Mock all masters found
        dark = {"filepath": "/library/dark.xisf"}
        bias = {"filepath": "/library/bias.xisf"}
        flat = {"filepath": "/library/flat.xisf"}
        mock_determine.return_value = {
            TYPE_MASTER_DARK: dark,
            TYPE_MASTER_BIAS: bias,
            TYPE_MASTER_FLAT: flat,
        }

        # Mock successful copy
        mock_copy.return_value = True

        stats = process_blink_directory(Path("/library"), Path("/blink"), dry_run=False)

        self.assertEqual(stats["configs_processed"], 1)
        self.assertEqual(stats["darks_copied"], 1)
        self.assertEqual(stats["biases_copied"], 1)
        self.assertEqual(stats["flats_copied"], 1)
        self.assertEqual(stats["darks_missing"], 0)
        self.assertEqual(stats["flats_missing"], 0)

    @patch("ap_copy_master_to_blink.copy_masters.scan_blink_directories")
    @patch("ap_copy_master_to_blink.copy_masters.group_lights_by_config")
    @patch("ap_copy_master_to_blink.copy_masters.determine_required_masters")
    @patch("ap_copy_master_to_blink.copy_masters.get_date_directory")
    @patch("ap_copy_master_to_blink.copy_masters.copy_master_to_blink")
    def test_process_blink_directory_missing_masters(
        self, mock_copy, mock_get_date, mock_determine, mock_group, mock_scan
    ):
        """Test processing with missing masters."""
        # Mock light metadata
        light_metadata = {
            "filepath": "/blink/M31/DATE_2024-01-15/FILTER_Ha/light.fits",
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: "100",
            NORMALIZED_HEADER_OFFSET: "50",
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILTER: "Ha",
            NORMALIZED_HEADER_DATE: "2024-01-15",
        }

        mock_scan.return_value = [light_metadata]
        mock_group.return_value = {("config_key",): [light_metadata]}
        mock_get_date.return_value = Path("/blink/M31/DATE_2024-01-15")

        # Mock no masters found
        mock_determine.return_value = {
            TYPE_MASTER_DARK: None,
            TYPE_MASTER_BIAS: None,
            TYPE_MASTER_FLAT: None,
        }

        stats = process_blink_directory(Path("/library"), Path("/blink"), dry_run=False)

        self.assertEqual(stats["configs_processed"], 1)
        self.assertEqual(stats["darks_copied"], 0)
        self.assertEqual(stats["biases_copied"], 0)
        self.assertEqual(stats["flats_copied"], 0)
        self.assertEqual(stats["darks_missing"], 1)
        self.assertEqual(stats["flats_missing"], 1)


class TestCLIFunctions(unittest.TestCase):
    """Test CLI helper functions."""

    def test_validate_directories_both_valid(self):
        """Test validation when both directories are valid."""
        with patch("pathlib.Path.exists", return_value=True):
            with patch("pathlib.Path.is_dir", return_value=True):
                is_valid, error = validate_directories(Path("/library"), Path("/blink"))

                self.assertTrue(is_valid)
                self.assertIsNone(error)

    def test_validate_directories_library_not_exists(self):
        """Test validation when library directory doesn't exist."""
        with patch("pathlib.Path.exists", side_effect=[False, True]):
            is_valid, error = validate_directories(Path("/library"), Path("/blink"))

            self.assertFalse(is_valid)
            self.assertIn("Library directory does not exist", error)

    def test_validate_directories_library_not_dir(self):
        """Test validation when library path is not a directory."""
        with patch("pathlib.Path.exists", return_value=True):
            with patch("pathlib.Path.is_dir", side_effect=[False, True]):
                is_valid, error = validate_directories(Path("/library"), Path("/blink"))

                self.assertFalse(is_valid)
                self.assertIn("Library path is not a directory", error)

    def test_validate_directories_blink_not_exists(self):
        """Test validation when blink directory doesn't exist."""
        with patch("pathlib.Path.exists", side_effect=[True, False]):
            with patch("pathlib.Path.is_dir", side_effect=[True]):
                is_valid, error = validate_directories(Path("/library"), Path("/blink"))

                self.assertFalse(is_valid)
                self.assertIn("Blink directory does not exist", error)

    def test_validate_directories_blink_not_dir(self):
        """Test validation when blink path is not a directory."""
        with patch("pathlib.Path.exists", return_value=True):
            with patch("pathlib.Path.is_dir", side_effect=[True, False]):
                is_valid, error = validate_directories(Path("/library"), Path("/blink"))

                self.assertFalse(is_valid)
                self.assertIn("Blink path is not a directory", error)

    @patch("sys.stdout", new_callable=StringIO)
    def test_print_header(self, mock_stdout):
        """Test header printing."""
        library_path = Path("/library")
        blink_path = Path("/blink")
        print_header(library_path, blink_path, dry_run=True)

        output = mock_stdout.getvalue()
        self.assertIn("ap-copy-master-to-blink", output)
        self.assertIn(f"Library: {library_path}", output)
        self.assertIn(f"Blink:   {blink_path}", output)
        self.assertIn("Dry-run: True", output)

    @patch("sys.stdout", new_callable=StringIO)
    def test_print_summary(self, mock_stdout):
        """Test summary printing."""
        stats = {
            "configs_processed": 2,
            "biases_copied": 1,
            "darks_copied": 2,
            "flats_copied": 3,
            "biases_missing": 0,
            "darks_missing": 1,
            "flats_missing": 0,
        }

        print_summary(stats)

        output = mock_stdout.getvalue()
        self.assertIn("Summary", output)
        self.assertIn("Unique configurations processed: 2", output)
        self.assertIn("Biases: 1", output)
        self.assertIn("Darks:  2", output)
        self.assertIn("Flats:  3", output)
        self.assertIn("Darks:  1", output)

    @patch("sys.stdout", new_callable=StringIO)
    def test_print_summary_order(self, mock_stdout):
        """Test that summary prints in bias, dark, flat order."""
        stats = {
            "configs_processed": 1,
            "biases_copied": 1,
            "darks_copied": 1,
            "flats_copied": 1,
            "biases_missing": 0,
            "darks_missing": 0,
            "flats_missing": 0,
        }

        print_summary(stats)

        output = mock_stdout.getvalue()
        # Find positions of each type in output
        bias_pos = output.find("Biases:")
        dark_pos = output.find("Darks:")
        flat_pos = output.find("Flats:")

        # Verify order: bias before dark before flat
        self.assertLess(bias_pos, dark_pos)
        self.assertLess(dark_pos, flat_pos)


if __name__ == "__main__":
    unittest.main()
