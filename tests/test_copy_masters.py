"""
Tests for copy logic

Generated By: Claude Code (Claude Sonnet 4.5)
"""

import unittest
from pathlib import Path
from unittest.mock import patch
from io import StringIO

from ap_copy_master_to_blink.copy_masters import (
    get_date_directory,
    scan_blink_directories,
    group_lights_by_config,
    copy_master_to_blink,
    check_masters_exist,
    process_blink_directory,
)
from ap_copy_master_to_blink.__main__ import (
    validate_directories,
    print_header,
    print_summary,
)
from ap_common.constants import (
    NORMALIZED_HEADER_CAMERA,
    NORMALIZED_HEADER_GAIN,
    NORMALIZED_HEADER_OFFSET,
    NORMALIZED_HEADER_SETTEMP,
    NORMALIZED_HEADER_READOUTMODE,
    NORMALIZED_HEADER_EXPOSURESECONDS,
    NORMALIZED_HEADER_FILTER,
    NORMALIZED_HEADER_DATE,
    NORMALIZED_HEADER_FILENAME,
    TYPE_MASTER_DARK,
    TYPE_MASTER_BIAS,
    TYPE_MASTER_FLAT,
)


class TestCopyMasters(unittest.TestCase):
    """Test copy logic."""

    def test_get_date_directory_from_filter_dir(self):
        """Test extracting DATE directory from FILTER directory."""
        lights_dir = Path("/blink/M31/DATE_2024-01-15/FILTER_Ha")
        result = get_date_directory(lights_dir)

        self.assertEqual(result.name, "DATE_2024-01-15")

    def test_get_date_directory_from_date_dir(self):
        """Test when already in DATE directory."""
        lights_dir = Path("/blink/M31/DATE_2024-01-15")
        result = get_date_directory(lights_dir)

        self.assertEqual(result.name, "DATE_2024-01-15")

    def test_get_date_directory_search_upward(self):
        """Test searching upward for DATE directory."""
        lights_dir = Path("/blink/M31/DATE_2024-01-15/FILTER_Ha/subdir")
        result = get_date_directory(lights_dir)

        self.assertEqual(result.name, "DATE_2024-01-15")

    @patch("ap_copy_master_to_blink.copy_masters.get_filtered_metadata")
    def test_scan_blink_directories(self, mock_get_filtered_metadata):
        """Test scanning blink directories for light frames."""
        # get_filtered_metadata returns a dict of {filename: metadata}
        mock_get_filtered_metadata.return_value = {
            "/blink/light1.fits": {NORMALIZED_HEADER_FILENAME: "/blink/light1.fits"},
            "/blink/light2.fits": {NORMALIZED_HEADER_FILENAME: "/blink/light2.fits"},
        }

        result = scan_blink_directories(Path("/blink"))

        self.assertEqual(len(result), 2)
        mock_get_filtered_metadata.assert_called_once()

    def test_group_lights_by_config(self):
        """Test grouping lights by calibration configuration."""
        metadata_list = [
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: "Ha",
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: "Ha",
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: "OIII",  # Different filter
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
        ]

        groups = group_lights_by_config(metadata_list)

        # Should have 2 groups (Ha and OIII)
        self.assertEqual(len(groups), 2)

        # Ha group should have 2 lights
        ha_groups = [g for g in groups.values() if len(g) == 2]
        self.assertEqual(len(ha_groups), 1)

        # OIII group should have 1 light
        oiii_groups = [g for g in groups.values() if len(g) == 1]
        self.assertEqual(len(oiii_groups), 1)

    def test_group_lights_by_config_none_filter_normalization(self):
        """Test that None filter values are normalized to empty string for grouping."""
        metadata_list = [
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: None,  # No filter
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: None,  # No filter
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: "Ha",  # Different filter
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
        ]

        groups = group_lights_by_config(metadata_list)

        # Should have 2 groups (None normalized to "" and "Ha")
        self.assertEqual(len(groups), 2)

        # None filter group should have 2 lights
        none_filter_groups = [g for g in groups.values() if len(g) == 2]
        self.assertEqual(len(none_filter_groups), 1)

        # Ha filter group should have 1 light
        ha_filter_groups = [g for g in groups.values() if len(g) == 1]
        self.assertEqual(len(ha_filter_groups), 1)

    def test_group_lights_by_config_multiple_none_values(self):
        """Test that multiple None values in different fields are normalized."""
        metadata_list = [
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: None,  # None value
                NORMALIZED_HEADER_OFFSET: None,  # None value
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: None,  # None value
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: None,  # None value
                NORMALIZED_HEADER_OFFSET: None,  # None value
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: None,  # None value
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
        ]

        groups = group_lights_by_config(metadata_list)

        # Should have 1 group (all None values normalized to "")
        self.assertEqual(len(groups), 1)

        # Group should contain both lights
        single_group = list(groups.values())[0]
        self.assertEqual(len(single_group), 2)

    @patch("ap_copy_master_to_blink.copy_masters.copy_file")
    def test_copy_master_to_blink_new_file(self, mock_copy_file):
        """Test copying master when file doesn't exist."""
        master_metadata = {NORMALIZED_HEADER_FILENAME: "/library/dark.xisf"}
        dest_dir = Path("/blink/DATE_2024-01-15")

        with patch("pathlib.Path.exists", return_value=False):
            result = copy_master_to_blink(master_metadata, dest_dir, dry_run=False)

        self.assertTrue(result)
        mock_copy_file.assert_called_once()

    def test_copy_master_to_blink_existing_file(self):
        """Test skipping copy when file already exists."""
        master_metadata = {NORMALIZED_HEADER_FILENAME: "/library/dark.xisf"}
        dest_dir = Path("/blink/DATE_2024-01-15")

        with patch("pathlib.Path.exists", return_value=True):
            result = copy_master_to_blink(master_metadata, dest_dir, dry_run=False)

        self.assertFalse(result)

    def test_copy_master_to_blink_dry_run(self):
        """Test dry-run mode doesn't copy files."""
        master_metadata = {NORMALIZED_HEADER_FILENAME: "/library/dark.xisf"}
        dest_dir = Path("/blink/DATE_2024-01-15")

        with patch("pathlib.Path.exists", return_value=False):
            with patch("ap_copy_master_to_blink.copy_masters.copy_file") as mock_copy:
                result = copy_master_to_blink(master_metadata, dest_dir, dry_run=True)

        self.assertTrue(result)
        mock_copy.assert_not_called()

    def test_check_masters_exist_no_directory(self):
        """Test check_masters_exist with non-existent directory."""
        dark = {NORMALIZED_HEADER_FILENAME: "/library/masterDark.xisf"}
        bias = {NORMALIZED_HEADER_FILENAME: "/library/masterBias.xisf"}
        flat = {NORMALIZED_HEADER_FILENAME: "/library/masterFlat.xisf"}

        result = check_masters_exist(Path("/nonexistent"), dark, bias, flat)

        self.assertFalse(result["has_dark"])
        self.assertFalse(result["has_bias"])
        self.assertFalse(result["has_flat"])

    def test_check_masters_exist_no_files_requested(self):
        """Test check_masters_exist when no specific files requested."""
        with patch("pathlib.Path.exists", return_value=True):
            result = check_masters_exist(Path("/blink/DATE_2024-01-15"))

        self.assertFalse(result["has_dark"])
        self.assertFalse(result["has_bias"])
        self.assertFalse(result["has_flat"])

    def test_check_masters_exist_dark_exists(self):
        """Test check_masters_exist finds existing dark file."""
        dark = {NORMALIZED_HEADER_FILENAME: "/library/masterDark.xisf"}

        def mock_exists(self):
            # Date directory exists, dark file exists
            posix_path = (
                self.as_posix()
                if hasattr(self, "as_posix")
                else str(self).replace("\\", "/")
            )
            return posix_path in [
                "/blink/DATE_2024-01-15",
                "/blink/DATE_2024-01-15/masterDark.xisf",
            ]

        with patch("pathlib.Path.exists", mock_exists):
            result = check_masters_exist(Path("/blink/DATE_2024-01-15"), dark=dark)

        self.assertTrue(result["has_dark"])
        self.assertFalse(result["has_bias"])
        self.assertFalse(result["has_flat"])

    def test_check_masters_exist_flat_exists(self):
        """Test check_masters_exist finds existing flat file."""
        flat = {NORMALIZED_HEADER_FILENAME: "/library/masterFlat.xisf"}

        def mock_exists(self):
            # Date directory exists, flat file exists
            posix_path = (
                self.as_posix()
                if hasattr(self, "as_posix")
                else str(self).replace("\\", "/")
            )
            return posix_path in [
                "/blink/DATE_2024-01-15",
                "/blink/DATE_2024-01-15/masterFlat.xisf",
            ]

        with patch("pathlib.Path.exists", mock_exists):
            result = check_masters_exist(Path("/blink/DATE_2024-01-15"), flat=flat)

        self.assertFalse(result["has_dark"])
        self.assertFalse(result["has_bias"])
        self.assertTrue(result["has_flat"])

    def test_check_masters_exist_all_exist(self):
        """Test check_masters_exist when all requested files exist."""
        dark = {NORMALIZED_HEADER_FILENAME: "/library/masterDark.xisf"}
        bias = {NORMALIZED_HEADER_FILENAME: "/library/masterBias.xisf"}
        flat = {NORMALIZED_HEADER_FILENAME: "/library/masterFlat.xisf"}

        def mock_exists(self):
            # Date directory and all master files exist
            posix_path = (
                self.as_posix()
                if hasattr(self, "as_posix")
                else str(self).replace("\\", "/")
            )
            return posix_path in [
                "/blink/DATE_2024-01-15",
                "/blink/DATE_2024-01-15/masterDark.xisf",
                "/blink/DATE_2024-01-15/masterBias.xisf",
                "/blink/DATE_2024-01-15/masterFlat.xisf",
            ]

        with patch("pathlib.Path.exists", mock_exists):
            result = check_masters_exist(
                Path("/blink/DATE_2024-01-15"), dark, bias, flat
            )

        self.assertTrue(result["has_dark"])
        self.assertTrue(result["has_bias"])
        self.assertTrue(result["has_flat"])

    def test_check_masters_exist_partial(self):
        """Test check_masters_exist when only some files exist."""
        dark = {NORMALIZED_HEADER_FILENAME: "/library/masterDark.xisf"}
        bias = {NORMALIZED_HEADER_FILENAME: "/library/masterBias.xisf"}
        flat = {NORMALIZED_HEADER_FILENAME: "/library/masterFlat.xisf"}

        def mock_exists(self):
            # Date directory exists, only dark exists
            posix_path = (
                self.as_posix()
                if hasattr(self, "as_posix")
                else str(self).replace("\\", "/")
            )
            return posix_path in [
                "/blink/DATE_2024-01-15",
                "/blink/DATE_2024-01-15/masterDark.xisf",
            ]

        with patch("pathlib.Path.exists", mock_exists):
            result = check_masters_exist(
                Path("/blink/DATE_2024-01-15"), dark, bias, flat
            )

        self.assertTrue(result["has_dark"])
        self.assertFalse(result["has_bias"])
        self.assertFalse(result["has_flat"])

    @patch("ap_copy_master_to_blink.copy_masters.scan_blink_directories")
    @patch("ap_copy_master_to_blink.copy_masters.determine_required_masters")
    @patch("ap_copy_master_to_blink.copy_masters.copy_master_to_blink")
    def test_process_blink_directory_no_lights(
        self, mock_copy, mock_determine, mock_scan
    ):
        """Test processing when no lights found."""
        mock_scan.return_value = []

        stats = process_blink_directory(Path("/library"), Path("/blink"), dry_run=False)

        self.assertEqual(stats["configs_processed"], 0)
        mock_determine.assert_not_called()
        mock_copy.assert_not_called()

    @patch("ap_copy_master_to_blink.copy_masters.scan_blink_directories")
    @patch("ap_copy_master_to_blink.copy_masters.group_lights_by_config")
    @patch("ap_copy_master_to_blink.copy_masters.determine_required_masters")
    @patch("ap_copy_master_to_blink.copy_masters.get_date_directory")
    @patch("ap_copy_master_to_blink.copy_masters.check_masters_exist")
    @patch("ap_copy_master_to_blink.copy_masters.copy_master_to_blink")
    def test_process_blink_directory_with_all_masters(
        self,
        mock_copy,
        mock_scan_existing,
        mock_get_date,
        mock_determine,
        mock_group,
        mock_scan,
    ):
        """Test processing with all master types found in library."""
        # Mock light metadata
        light_metadata = {
            NORMALIZED_HEADER_FILENAME: (
                "/blink/M31/DATE_2024-01-15" "/FILTER_Ha/light.fits"
            ),
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: "100",
            NORMALIZED_HEADER_OFFSET: "50",
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILTER: "Ha",
            NORMALIZED_HEADER_DATE: "2024-01-15",
        }

        mock_scan.return_value = [light_metadata]
        mock_group.return_value = {("config_key",): [light_metadata]}
        mock_get_date.return_value = Path("/blink/M31/DATE_2024-01-15")

        # Mock no existing masters in blink
        mock_scan_existing.return_value = {
            "has_dark": False,
            "has_bias": False,
            "has_flat": False,
        }

        # Mock all masters found in library
        dark = {NORMALIZED_HEADER_FILENAME: "/library/dark.xisf"}
        bias = {NORMALIZED_HEADER_FILENAME: "/library/bias.xisf"}
        flat = {NORMALIZED_HEADER_FILENAME: "/library/flat.xisf"}
        mock_determine.return_value = {
            TYPE_MASTER_DARK: dark,
            TYPE_MASTER_BIAS: bias,
            TYPE_MASTER_FLAT: flat,
        }

        # Mock successful copy
        mock_copy.return_value = True

        stats = process_blink_directory(Path("/library"), Path("/blink"), dry_run=False)

        self.assertEqual(stats["frame_count"], 1)
        self.assertEqual(stats["target_count"], 1)
        self.assertEqual(stats["date_count"], 1)
        self.assertEqual(stats["filter_count"], 1)
        self.assertEqual(stats["configs_processed"], 1)
        self.assertEqual(stats["darks_needed"], 1)
        self.assertEqual(stats["darks_present"], 1)
        self.assertEqual(stats["biases_needed"], 1)
        self.assertEqual(stats["biases_present"], 1)
        self.assertEqual(stats["flats_needed"], 1)
        self.assertEqual(stats["flats_present"], 1)

    @patch("ap_copy_master_to_blink.copy_masters.scan_blink_directories")
    @patch("ap_copy_master_to_blink.copy_masters.group_lights_by_config")
    @patch("ap_copy_master_to_blink.copy_masters.determine_required_masters")
    @patch("ap_copy_master_to_blink.copy_masters.get_date_directory")
    @patch("ap_copy_master_to_blink.copy_masters.check_masters_exist")
    @patch("ap_copy_master_to_blink.copy_masters.copy_master_to_blink")
    def test_process_blink_directory_missing_masters(
        self,
        mock_copy,
        mock_scan_existing,
        mock_get_date,
        mock_determine,
        mock_group,
        mock_scan,
    ):
        """Test processing with masters missing from both library and blink."""
        # Mock light metadata
        light_metadata = {
            NORMALIZED_HEADER_FILENAME: (
                "/blink/M31/DATE_2024-01-15" "/FILTER_Ha/light.fits"
            ),
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: "100",
            NORMALIZED_HEADER_OFFSET: "50",
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILTER: "Ha",
            NORMALIZED_HEADER_DATE: "2024-01-15",
        }

        mock_scan.return_value = [light_metadata]
        mock_group.return_value = {("config_key",): [light_metadata]}
        mock_get_date.return_value = Path("/blink/M31/DATE_2024-01-15")

        # Mock no existing masters in blink
        mock_scan_existing.return_value = {
            "has_dark": False,
            "has_bias": False,
            "has_flat": False,
        }

        # Mock no masters found in library
        mock_determine.return_value = {
            TYPE_MASTER_DARK: None,
            TYPE_MASTER_BIAS: None,
            TYPE_MASTER_FLAT: None,
        }

        stats = process_blink_directory(Path("/library"), Path("/blink"), dry_run=False)

        self.assertEqual(stats["frame_count"], 1)
        self.assertEqual(stats["target_count"], 1)
        self.assertEqual(stats["date_count"], 1)
        self.assertEqual(stats["filter_count"], 1)
        self.assertEqual(stats["configs_processed"], 1)
        self.assertEqual(stats["darks_needed"], 1)
        self.assertEqual(stats["darks_present"], 0)
        self.assertEqual(stats["biases_needed"], 0)
        self.assertEqual(stats["biases_present"], 0)
        self.assertEqual(stats["flats_needed"], 1)
        self.assertEqual(stats["flats_present"], 0)

    @patch("ap_copy_master_to_blink.copy_masters.scan_blink_directories")
    @patch("ap_copy_master_to_blink.copy_masters.group_lights_by_config")
    @patch("ap_copy_master_to_blink.copy_masters.determine_required_masters")
    @patch("ap_copy_master_to_blink.copy_masters.get_date_directory")
    @patch("ap_copy_master_to_blink.copy_masters.check_masters_exist")
    @patch("ap_copy_master_to_blink.copy_masters.copy_master_to_blink")
    def test_process_blink_directory_masters_already_in_blink(
        self,
        mock_copy,
        mock_scan_existing,
        mock_get_date,
        mock_determine,
        mock_group,
        mock_scan,
    ):
        """Test processing when masters exist in blink but not in library."""
        # Mock light metadata
        light_metadata = {
            NORMALIZED_HEADER_FILENAME: (
                "/blink/M31/DATE_2024-01-15" "/FILTER_Ha/light.fits"
            ),
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: "100",
            NORMALIZED_HEADER_OFFSET: "50",
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILTER: "Ha",
            NORMALIZED_HEADER_DATE: "2024-01-15",
        }

        mock_scan.return_value = [light_metadata]
        mock_group.return_value = {("config_key",): [light_metadata]}
        mock_get_date.return_value = Path("/blink/M31/DATE_2024-01-15")

        # Mock masters already exist in blink (e.g., manually copied)
        mock_scan_existing.return_value = {
            "has_dark": True,
            "has_bias": False,
            "has_flat": True,
        }

        # Mock no masters found in library
        mock_determine.return_value = {
            TYPE_MASTER_DARK: None,
            TYPE_MASTER_BIAS: None,
            TYPE_MASTER_FLAT: None,
        }

        stats = process_blink_directory(Path("/library"), Path("/blink"), dry_run=False)

        self.assertEqual(stats["frame_count"], 1)
        self.assertEqual(stats["configs_processed"], 1)
        self.assertEqual(stats["darks_needed"], 1)
        self.assertEqual(stats["darks_present"], 1)  # Found locally
        self.assertEqual(stats["flats_needed"], 1)
        self.assertEqual(stats["flats_present"], 1)  # Found locally
        # Should not try to copy since they exist locally
        mock_copy.assert_not_called()


class TestCLIFunctions(unittest.TestCase):
    """Test CLI helper functions."""

    def test_validate_directories_both_valid(self):
        """Test validation when both directories are valid."""
        with patch("pathlib.Path.exists", return_value=True):
            with patch("pathlib.Path.is_dir", return_value=True):
                is_valid, error = validate_directories(Path("/library"), Path("/blink"))

                self.assertTrue(is_valid)
                self.assertIsNone(error)

    def test_validate_directories_library_not_exists(self):
        """Test validation when library directory doesn't exist."""
        with patch("pathlib.Path.exists", side_effect=[False, True]):
            is_valid, error = validate_directories(Path("/library"), Path("/blink"))

            self.assertFalse(is_valid)
            self.assertIn("Library directory does not exist", error)

    def test_validate_directories_library_not_dir(self):
        """Test validation when library path is not a directory."""
        with patch("pathlib.Path.exists", return_value=True):
            with patch("pathlib.Path.is_dir", side_effect=[False, True]):
                is_valid, error = validate_directories(Path("/library"), Path("/blink"))

                self.assertFalse(is_valid)
                self.assertIn("Library path is not a directory", error)

    def test_validate_directories_blink_not_exists(self):
        """Test validation when blink directory doesn't exist."""
        with patch("pathlib.Path.exists", side_effect=[True, False]):
            with patch("pathlib.Path.is_dir", side_effect=[True]):
                is_valid, error = validate_directories(Path("/library"), Path("/blink"))

                self.assertFalse(is_valid)
                self.assertIn("Blink directory does not exist", error)

    def test_validate_directories_blink_not_dir(self):
        """Test validation when blink path is not a directory."""
        with patch("pathlib.Path.exists", return_value=True):
            with patch("pathlib.Path.is_dir", side_effect=[True, False]):
                is_valid, error = validate_directories(Path("/library"), Path("/blink"))

                self.assertFalse(is_valid)
                self.assertIn("Blink path is not a directory", error)

    @patch("sys.stdout", new_callable=StringIO)
    def test_print_header(self, mock_stdout):
        """Test header printing."""
        library_path = Path("/library")
        blink_path = Path("/blink")
        print_header(library_path, blink_path, dry_run=True)

        output = mock_stdout.getvalue()
        self.assertIn("ap-copy-master-to-blink", output)
        self.assertIn(f"Library: {library_path}", output)
        self.assertIn(f"Blink:   {blink_path}", output)
        self.assertIn("Dry-run: True", output)

    @patch("sys.stdout", new_callable=StringIO)
    def test_print_summary(self, mock_stdout):
        """Test summary printing."""
        stats = {
            "frame_count": 100,
            "target_count": 2,
            "date_count": 1,
            "filter_count": 1,
            "configs_processed": 2,
            "darks_needed": 3,
            "darks_present": 2,
            "biases_needed": 1,
            "biases_present": 1,
            "flats_needed": 3,
            "flats_present": 3,
        }

        print_summary(stats)

        output = mock_stdout.getvalue()
        self.assertIn("Summary", output)
        self.assertIn("Frames: 100 lights (2 targets, 1 date, 1 filter)", output)
        self.assertIn("Darks:  2 of 3 | MISSING!", output)
        self.assertIn("Biases: 1 of 1 | ok", output)
        self.assertIn("Flats:  3 of 3 | ok", output)
        self.assertNotIn("Configurations:", output)

    @patch("sys.stdout", new_callable=StringIO)
    def test_print_summary_order(self, mock_stdout):
        """Test that summary prints in bias, dark, flat order."""
        stats = {
            "frame_count": 50,
            "target_count": 1,
            "date_count": 1,
            "filter_count": 1,
            "configs_processed": 1,
            "darks_needed": 1,
            "darks_present": 1,
            "biases_needed": 1,
            "biases_present": 1,
            "flats_needed": 1,
            "flats_present": 1,
        }

        print_summary(stats)

        output = mock_stdout.getvalue()
        # Find positions of each type in output
        dark_pos = output.find("Darks:")
        bias_pos = output.find("Biases:")
        flat_pos = output.find("Flats:")

        # Verify order: bias before dark before flat
        self.assertLess(bias_pos, dark_pos)
        self.assertLess(dark_pos, flat_pos)


class TestIntegration(unittest.TestCase):
    """Integration tests that call real functions without mocking."""

    def test_process_blink_directory_uses_filename_key(self):
        """Test process_blink_directory uses correct 'filename' key.

        Regression test for bug where code used 'filepath' key
        but metadata uses 'filename' (NORMALIZED_HEADER_FILENAME).
        """
        import tempfile
        from ap_copy_master_to_blink.copy_masters import process_blink_directory

        with tempfile.TemporaryDirectory() as tmpdir:
            library_dir = Path(tmpdir) / "library"
            blink_dir = Path(tmpdir) / "blink"
            library_dir.mkdir()
            blink_dir.mkdir()

            # Create a fake light file (won't be valid FITS but that's okay)
            light_file = blink_dir / "light1.fits"
            light_file.write_text("fake fits")

            # This should not raise KeyError: 'filepath'
            try:
                stats = process_blink_directory(library_dir, blink_dir, dry_run=True)
                # We expect missing masters but no KeyError
                self.assertIsInstance(stats, dict)
            except KeyError as e:
                if NORMALIZED_HEADER_FILENAME in str(e):
                    self.fail(f"Code uses 'filepath' instead of 'filename': {e}")
                raise
            except OSError:
                # FITS parsing errors are expected with fake files
                pass


class TestIntegrationOld(unittest.TestCase):
    """Integration tests that call real functions without mocking."""

    @patch("ap_copy_master_to_blink.copy_masters.determine_required_masters")
    @patch("ap_copy_master_to_blink.copy_masters.check_masters_exist")
    @patch("ap_copy_master_to_blink.copy_masters.copy_master_to_blink")
    def test_copies_to_all_target_directories_in_group(
        self, mock_copy_master, mock_scan_existing, mock_determine
    ):
        """Test that masters are copied to ALL target directories with same config.

        Regression test for bug where lights from multiple targets with the same
        calibration config were grouped together, but masters were only copied to
        the first target's directory.
        """
        from ap_copy_master_to_blink.copy_masters import process_blink_directory

        # Two targets, both with H filter 300s exposure
        # Should copy masters to BOTH target directories
        mock_scan_data = [
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: "H",
                NORMALIZED_HEADER_DATE: "2026-02-07",
                NORMALIZED_HEADER_FILENAME: (
                    "/blink/Target1/DATE_2026-02-07" "/FILTER_H/light1.xisf"
                ),
            },
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: "H",
                NORMALIZED_HEADER_DATE: "2026-02-07",
                NORMALIZED_HEADER_FILENAME: (
                    "/blink/Target2/DATE_2026-02-07" "/FILTER_H/light2.xisf"
                ),
            },
        ]

        from ap_common.constants import (
            TYPE_MASTER_DARK,
            TYPE_MASTER_BIAS,
            TYPE_MASTER_FLAT,
        )

        mock_masters = {
            TYPE_MASTER_DARK: {NORMALIZED_HEADER_FILENAME: "/library/dark.xisf"},
            TYPE_MASTER_BIAS: None,
            TYPE_MASTER_FLAT: {NORMALIZED_HEADER_FILENAME: "/library/flat.xisf"},
        }
        mock_determine.return_value = mock_masters
        mock_copy_master.return_value = True

        # Mock no existing masters in blink
        mock_scan_existing.return_value = {
            "has_dark": False,
            "has_bias": False,
            "has_flat": False,
        }

        with patch(
            "ap_copy_master_to_blink.copy_masters.scan_blink_directories",
            return_value=mock_scan_data,
        ):
            process_blink_directory(Path("/library"), Path("/blink"), dry_run=False)

        # Should have called copy_master_to_blink for both directories
        # 2 targets * 2 masters (dark + flat) = 4 copies
        self.assertEqual(mock_copy_master.call_count, 4)

        # Verify it was called with both target directories
        # Normalize paths to use forward slashes for comparison
        called_dirs = {
            str(call[0][1]).replace("\\", "/")
            for call in mock_copy_master.call_args_list
        }
        self.assertIn("/blink/Target1/DATE_2026-02-07", called_dirs)
        self.assertIn("/blink/Target2/DATE_2026-02-07", called_dirs)

    def test_copy_file_receives_strings_not_paths(self):
        """Test that copy_file is called with strings, not Path objects.

        Regression test for bug where Path objects were passed to copy_file
        which expects strings.
        """
        import tempfile
        from ap_copy_master_to_blink.copy_masters import copy_master_to_blink

        with tempfile.TemporaryDirectory() as tmpdir:
            # Create source file
            library_dir = Path(tmpdir) / "library"
            library_dir.mkdir()
            source_file = library_dir / "masterDark.xisf"
            source_file.write_text("fake xisf")

            # Create dest directory
            dest_dir = Path(tmpdir) / "blink" / "DATE_2024-01-15"
            dest_dir.mkdir(parents=True)

            master_metadata = {NORMALIZED_HEADER_FILENAME: str(source_file)}

            # Should not raise AttributeError about
            # Path object missing 'split'
            try:
                result = copy_master_to_blink(master_metadata, dest_dir, dry_run=False)
                self.assertTrue(result)
                # Verify file was copied
                dest_file = dest_dir / source_file.name
                self.assertTrue(dest_file.exists())
            except AttributeError as e:
                if "'WindowsPath' object has no attribute 'split'" in str(
                    e
                ) or "'PosixPath' object has no attribute 'split'" in str(e):
                    self.fail(f"copy_file received Path object instead of string: {e}")
                raise

    @patch("ap_copy_master_to_blink.matching.find_darks_util")
    def test_get_filtered_metadata_returns_dict(self, mock_find_darks):
        """Test that find_matching_dark handles list return from utility.

        Regression test - updated for new utility-based implementation.
        """
        from ap_copy_master_to_blink.matching import find_matching_dark
        from ap_common.constants import (
            NORMALIZED_HEADER_EXPOSURESECONDS,
            NORMALIZED_HEADER_FILENAME,
        )

        # Utility returns list of metadata dicts (sorted by exposure, longest first)
        mock_find_darks.return_value = [
            {
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILENAME: "/test/dark1.xisf",
            },
            {
                NORMALIZED_HEADER_EXPOSURESECONDS: "120",
                NORMALIZED_HEADER_FILENAME: "/test/dark2.xisf",
            },
        ]

        light_metadata = {
            "camera": "TestCamera",
            "gain": "100",
            "offset": "50",
            "settemp": "-10.00",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
        }

        # Should return first match (exact exposure match)
        result = find_matching_dark(Path("/test/library"), light_metadata)
        self.assertIsNotNone(result)
        self.assertEqual(result[NORMALIZED_HEADER_EXPOSURESECONDS], "300")

    def test_find_matching_dark_integration(self):
        """Test find_matching_dark with real get_filtered_metadata call.

        Regression test for bug where get_filtered_metadata was called
        with only (library_dir, filter_criteria) but requires profileFromPath.
        """
        import tempfile
        from ap_copy_master_to_blink.matching import find_matching_dark

        with tempfile.TemporaryDirectory() as tmpdir:
            library_dir = Path(tmpdir) / "library"
            library_dir.mkdir()

            light_metadata = {
                NORMALIZED_HEADER_CAMERA: "TestCam",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "10",
                NORMALIZED_HEADER_SETTEMP: "-10.00",
                NORMALIZED_HEADER_READOUTMODE: "HighGain",
                NORMALIZED_HEADER_EXPOSURESECONDS: "60.00",
            }

            # This should not raise TypeError about missing profileFromPath
            try:
                result = find_matching_dark(library_dir, light_metadata)
                # We expect None because no masters exist in empty directory
                self.assertIsNone(result)
            except TypeError as e:
                if "profileFromPath" in str(e):
                    self.fail(f"get_filtered_metadata() API mismatch: {e}")
                raise

    def test_find_matching_dark_with_missing_metadata(self):
        """Test find_matching_dark handles missing metadata fields.

        Tests that matching works with empty string (normalized from None).
        """
        import tempfile
        from ap_copy_master_to_blink.matching import find_matching_dark

        with tempfile.TemporaryDirectory() as tmpdir:
            library_dir = Path(tmpdir) / "library"
            library_dir.mkdir()

            # Light metadata with missing readoutmode (normalized to empty string)
            light_metadata = {
                NORMALIZED_HEADER_CAMERA: "TestCam",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "10",
                NORMALIZED_HEADER_SETTEMP: "-10.00",
                NORMALIZED_HEADER_READOUTMODE: "",  # Normalized from None
                NORMALIZED_HEADER_EXPOSURESECONDS: "60.00",
            }

            result = find_matching_dark(library_dir, light_metadata)
            # We expect None because no masters exist
            self.assertIsNone(result)

    def test_scan_blink_directories_integration(self):
        """Test scan_blink_directories with real get_filenames call.

        This integration test ensures the function signature matches between
        scan_blink_directories and get_filenames from ap-common.

        Regression test for bugs where:
        1. get_filenames was called with extensions= parameter (doesn't exist)
        2. blink_dir was passed as string instead of list to get_filenames
        """
        import tempfile

        # Create temporary directory structure
        with tempfile.TemporaryDirectory() as tmpdir:
            blink_dir = Path(tmpdir) / "blink"
            blink_dir.mkdir()

            # Create some test files
            (blink_dir / "light1.fits").write_text("fake fits data")
            (blink_dir / "light2.xisf").write_text("fake xisf data")
            (blink_dir / "ignore.txt").write_text("should be ignored")

            # Should not raise TypeError about unexpected
            # keyword argument 'extensions' or AttributeError
            # about string not having certain attributes
            try:
                result = scan_blink_directories(blink_dir)
                # We expect empty list because files don't have valid metadata
                # but the function should execute without parameter errors
                self.assertIsInstance(result, list)
            except TypeError as e:
                if "extensions" in str(e) or "got an unexpected keyword" in str(e):
                    self.fail(f"API mismatch: {e}")
                raise
            except OSError as e:
                # FITS parsing may fail - we're testing
                # API compatibility, not FITS parsing
                if "SIMPLE card" not in str(e):
                    raise

    def test_validate_directories_integration(self):
        """Test validate_directories requires Path objects, not strings.

        Regression test for bug where resolve_path returns string
        but validate_directories expected Path objects. The fix was to
        wrap resolve_path results with Path() in main().
        """
        import tempfile

        with tempfile.TemporaryDirectory() as tmpdir:
            library_dir = Path(tmpdir) / "library"
            blink_dir = Path(tmpdir) / "blink"
            library_dir.mkdir()
            blink_dir.mkdir()

            # validate_directories should work with Path objects
            is_valid, error = validate_directories(library_dir, blink_dir)
            self.assertTrue(is_valid)
            self.assertIsNone(error)

            # validate_directories should NOT work with strings (by design)
            # main() must wrap resolve_path() results with Path()
            with self.assertRaises(AttributeError):
                validate_directories(str(library_dir), str(blink_dir))


class TestPrintSummary(unittest.TestCase):
    """Tests for print_summary function.

    CRITICAL: These tests enforce the required output order and format.
    The output order has regressed multiple times and must be protected.
    """

    @patch("sys.stdout", new_callable=StringIO)
    def test_output_order_is_bias_dark_flat(self, mock_stdout):
        """Verify output order is ALWAYS: Biases, Darks, Flats.

        CRITICAL: This order must not change. Update this test only if
        there is an explicit business requirement to change the order.
        """
        stats = {
            "frame_count": 100,
            "target_count": 3,
            "date_count": 5,
            "filter_count": 4,
            "darks_needed": 10,
            "darks_present": 8,
            "flats_needed": 10,
            "flats_present": 9,
            "biases_needed": 5,
            "biases_present": 4,
        }

        print_summary(stats)

        output = mock_stdout.getvalue()
        output_lines = output.split("\n")

        # Find the calibration frame lines
        calibration_lines = [
            line
            for line in output_lines
            if any(frame in line for frame in ["Biases:", "Darks:", "Flats:"])
        ]

        # CRITICAL: Verify order is Biases, Darks, Flats
        self.assertEqual(
            len(calibration_lines),
            3,
            f"Expected 3 calibration lines, got {len(calibration_lines)}",
        )
        self.assertIn(
            "Biases:",
            calibration_lines[0],
            f"First line should be Biases, got: {calibration_lines[0]}",
        )
        self.assertIn(
            "Darks:",
            calibration_lines[1],
            f"Second line should be Darks, got: {calibration_lines[1]}",
        )
        self.assertIn(
            "Flats:",
            calibration_lines[2],
            f"Third line should be Flats, got: {calibration_lines[2]}",
        )

    @patch("sys.stdout", new_callable=StringIO)
    def test_bias_always_shown_even_when_zero(self, mock_stdout):
        """Verify bias is ALWAYS shown, even when 0 of 0.

        CRITICAL: Bias must always appear in output regardless of whether
        bias frames are needed or present.
        """
        stats = {
            "frame_count": 50,
            "target_count": 2,
            "date_count": 3,
            "filter_count": 2,
            "darks_needed": 5,
            "darks_present": 5,
            "flats_needed": 5,
            "flats_present": 5,
            "biases_needed": 0,  # No bias needed
            "biases_present": 0,  # No bias present
        }

        print_summary(stats)

        output = mock_stdout.getvalue()

        # CRITICAL: Bias line must be present
        self.assertIn("Biases:", output, "Bias line must always be present in output")
        self.assertIn(
            "0 of 0", output, "Should show 0 of 0 when no bias needed or present"
        )

    @patch("sys.stdout", new_callable=StringIO)
    def test_bias_shown_when_all_missing(self, mock_stdout):
        """Verify bias is shown when all directories are missing bias (0 of N)."""
        stats = {
            "frame_count": 50,
            "target_count": 2,
            "date_count": 3,
            "filter_count": 2,
            "darks_needed": 10,
            "darks_present": 10,
            "flats_needed": 10,
            "flats_present": 10,
            "biases_needed": 10,  # Bias needed
            "biases_present": 0,  # But none present
        }

        print_summary(stats)

        output = mock_stdout.getvalue()

        # CRITICAL: Bias line must be present showing 0 of 10
        self.assertIn(
            "Biases:", output, "Bias line must be present even when all missing"
        )
        self.assertIn(
            "0 of 10",
            output,
            "Should show 0 of 10 when all biases missing",
        )

    @patch("sys.stdout", new_callable=StringIO)
    def test_order_consistent_regardless_of_values(self, mock_stdout):
        """Verify order remains Biases, Darks, Flats
        regardless of which have 0."""
        # All frames missing
        stats = {
            "frame_count": 100,
            "target_count": 5,
            "date_count": 10,
            "filter_count": 3,
            "darks_needed": 20,
            "darks_present": 0,
            "flats_needed": 20,
            "flats_present": 0,
            "biases_needed": 10,
            "biases_present": 0,
        }

        print_summary(stats)

        output = mock_stdout.getvalue()
        output_lines = output.split("\n")

        calibration_lines = [
            line
            for line in output_lines
            if any(frame in line for frame in ["Biases:", "Darks:", "Flats:"])
        ]

        # Order must still be Biases, Darks, Flats
        self.assertIn("Biases:", calibration_lines[0])
        self.assertIn("Darks:", calibration_lines[1])
        self.assertIn("Flats:", calibration_lines[2])


if __name__ == "__main__":
    unittest.main()
