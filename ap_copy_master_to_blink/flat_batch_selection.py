"""
Batch flat selection logic for multiple filters per date

Generated By: Claude Code (Claude Sonnet 4.5)
"""

from datetime import date as date_type
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple
import logging

from ap_common.constants import (
    NORMALIZED_HEADER_FILTER,
    TYPE_MASTER_FLAT,
)

from ap_common.progress import progress_iter

from .matching import (
    find_candidate_flat_dates,
    find_flat_for_date,
    determine_required_masters,
)
from .flat_state import get_cutoff, update_cutoff
from .picker import pick_flat_date

logger = logging.getLogger(__name__)


def find_candidate_dates_with_all_filters(
    library_dir: Path,
    light_metadata: Dict[str, str],
    required_filters: Set[str],
    cutoff_date: Optional[str],
) -> Dict[str, Dict[str, str]]:
    """
    Find candidate flat dates that have flats for ALL required filters.

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata from one light (for equipment matching)
        required_filters: Set of filter names needed
        cutoff_date: Exclude dates older than this

    Returns:
        Map: {date_str → flat_metadata}
        Only includes dates with complete filter coverage
    """
    if not required_filters:
        return {}

    # For each required filter, find candidate dates
    candidates_per_filter: Dict[str, Set[str]] = {}

    for filter_name in required_filters:
        # Modify metadata to search for this filter
        search_metadata = dict(light_metadata)
        search_metadata[NORMALIZED_HEADER_FILTER] = filter_name

        # Find all dates with this filter (ignoring date field)
        candidates = find_candidate_flat_dates(
            library_dir, search_metadata, cutoff_date
        )
        candidates_per_filter[filter_name] = set(candidates.keys())

    # Intersect: only dates that have ALL filters
    if candidates_per_filter:
        valid_dates = set.intersection(*candidates_per_filter.values())
    else:
        valid_dates = set()

    # Return map: {date → flat_metadata for one filter (doesn't matter which)}
    result: Dict[str, Dict[str, str]] = {}
    for date_str in valid_dates:
        # Pick first filter's metadata as representative
        first_filter = next(iter(required_filters))
        search_metadata = dict(light_metadata)
        search_metadata[NORMALIZED_HEADER_FILTER] = first_filter
        flat = find_flat_for_date(library_dir, search_metadata, date_str)
        if flat:
            result[date_str] = flat

    return result


def resolve_flat_for_date(
    library_dir: Path,
    light_metadata: Dict[str, str],
    light_date: str,
    required_filters: Set[str],
    blink_dir_str: str,
    state: Dict[str, str],
    quiet: bool,
    picker_limit: int,
) -> Optional[str]:
    """
    Resolve flat date for a light date (ALL filters).

    Called when no exact-date flat exists for any filter on this date
    and --flat-state is enabled.

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata from one light (for equipment matching)
        light_date: Light frame date string (YYYY-MM-DD)
        required_filters: Set of filter names needed for this date
        blink_dir_str: Blink directory path string (state file key)
        state: State dictionary (modified in place)
        quiet: If True, skip interactive selection
        picker_limit: Max older/newer dates to show in picker

    Returns:
        Selected flat date string, or None if user chose "rig changed"
    """
    if quiet:
        # Quiet mode: no fallback, no prompting
        filter_names = ", ".join(sorted(required_filters))
        logger.debug(
            f"Quiet mode: skipping flexible flat matching for "
            f"date={light_date}, filters={filter_names}"
        )
        return None

    # Get cutoff from state
    cutoff = get_cutoff(state, blink_dir_str)

    filter_names = ", ".join(sorted(required_filters))
    logger.info(
        f"No exact flat for date={light_date}, "
        f"searching candidates: filters={filter_names}"
    )

    # Find candidates with ALL filters
    candidates = find_candidate_dates_with_all_filters(
        library_dir, light_metadata, required_filters, cutoff
    )

    # Remove exact date (already tried and failed)
    candidates.pop(light_date, None)

    if not candidates:
        logger.debug(
            f"No candidates with all filters for {light_date} "
            f"(filters: {', '.join(sorted(required_filters))})"
        )
        return None

    # Split into older and newer relative to light date
    try:
        light_date_obj = date_type.fromisoformat(light_date)
    except (ValueError, TypeError):
        logger.warning(f"Invalid light date: {light_date}")
        return None

    older_dates: List[date_type] = []
    newer_dates: List[date_type] = []

    for date_str in sorted(candidates.keys()):
        try:
            d = date_type.fromisoformat(date_str)
        except (ValueError, TypeError):
            continue
        if d < light_date_obj:
            older_dates.append(d)
        elif d > light_date_obj:
            newer_dates.append(d)

    if not older_dates and not newer_dates:
        logger.debug("No older or newer candidate flat dates")
        return None

    # Show interactive picker ONCE for this date
    selected_date = pick_flat_date(
        light_date,
        f"ALL ({filter_names})",  # Show all filters in prompt
        older_dates,
        newer_dates,
        picker_limit=picker_limit,
    )

    if selected_date is None:
        # User chose "rig changed" - update cutoff to light date
        update_cutoff(state, blink_dir_str, light_date)
        logger.info(f"Rig change recorded at {light_date} (filters: {filter_names})")
        return None

    # User selected a date - update cutoff
    selected_date_str = selected_date.isoformat()
    update_cutoff(state, blink_dir_str, selected_date_str)
    logger.info(
        f"Selected flat date {selected_date_str} for {light_date} "
        f"(filters: {filter_names})"
    )

    return selected_date_str


def pre_prompt_flat_selections(
    library_dir: Path,
    groups: Dict[Tuple, List[Dict[str, str]]],
    filters_by_date: Dict[str, Set[str]],
    blink_dir_str: str,
    state: Dict[str, str],
    quiet: bool,
    scale_darks: bool,
    picker_limit: int,
) -> Dict[str, Optional[str]]:
    """
    Orchestrate pre-prompting for all dates needing flat selection.

    This prompts ONCE per date (not per filter) for better UX when multiple
    filters are needed on the same date.

    Args:
        library_dir: Path to calibration library
        groups: Output from group_lights_by_config()
        filters_by_date: Map of {date_str → set of filter names}
        blink_dir_str: Blink directory path string (state file key)
        state: State dictionary (modified in place)
        quiet: If True, skip interactive selection
        scale_darks: Whether to allow scaled darks
            (passed to determine_required_masters)
        picker_limit: Max older/newer dates to show in picker

    Returns:
        Map of {light_date → selected_flat_date}
        selected_flat_date is None if user chose "rig changed"
    """
    flat_selections: Dict[str, Optional[str]] = {}
    sorted_dates = sorted(filters_by_date.keys())

    # Phase 1: Check which dates need flat selection (with progress)
    dates_needing_selection: Dict[str, Tuple[Dict[str, str], Set[str]]] = {}

    for light_date in progress_iter(
        sorted_dates,
        desc="Checking flats",
        unit="dates",
        enabled=not quiet,
    ):
        filters_needed = filters_by_date[light_date]

        # Check if any group for this date needs flat selection
        needs_selection = False
        representative_light = None

        for config_key, lights in groups.items():
            # Defensive: check tuple length
            if len(config_key) >= 8 and config_key[7] == light_date:  # date field
                # Use first light as representative for equipment matching
                light_metadata = lights[0]
                representative_light = light_metadata

                # Try exact match first
                masters = determine_required_masters(
                    library_dir, light_metadata, scale_darks
                )
                if masters[TYPE_MASTER_FLAT] is None:
                    needs_selection = True
                    break

        if needs_selection and representative_light is not None:
            dates_needing_selection[light_date] = (
                representative_light,
                filters_needed,
            )

    # Phase 2: Resolve flat dates for dates without exact matches
    for light_date, (
        representative_light,
        filters_needed,
    ) in dates_needing_selection.items():
        selected_date = resolve_flat_for_date(
            library_dir,
            representative_light,
            light_date,
            filters_needed,
            blink_dir_str,
            state,
            quiet,
            picker_limit,
        )
        flat_selections[light_date] = selected_date

    return flat_selections
