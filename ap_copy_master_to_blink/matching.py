"""
Library search and matching logic for master calibration frames

Generated By: Claude Code (Claude Sonnet 4.5)
"""

from typing import Dict, List, Optional
from pathlib import Path
import logging

from ap_common import get_filtered_metadata
from ap_common.constants import (
    TYPE_MASTER_DARK,
    TYPE_MASTER_FLAT,
    TYPE_MASTER_BIAS,
    NORMALIZED_HEADER_TYPE,
    NORMALIZED_HEADER_CAMERA,
    NORMALIZED_HEADER_GAIN,
    NORMALIZED_HEADER_OFFSET,
    NORMALIZED_HEADER_SETTEMP,
    NORMALIZED_HEADER_READOUTMODE,
    NORMALIZED_HEADER_EXPOSURESECONDS,
    NORMALIZED_HEADER_DATE,
    NORMALIZED_HEADER_FILTER,
    NORMALIZED_HEADER_OPTIC,
    NORMALIZED_HEADER_FOCALLEN,
)

from .config import SUPPORTED_EXTENSIONS

logger = logging.getLogger(__name__)


def find_matching_dark(
    library_dir: Path,
    light_metadata: Dict[str, str],
    allow_bias: bool = False,
) -> Optional[Dict[str, str]]:
    """
    Find matching dark frame for a light frame.

    Priority:
    1. Exact exposure match
    2. If allow_bias=True and no exact match: Find longest dark exposure < light exposure

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame
        allow_bias: If False, only exact exposure match darks are returned.
                   If True, shorter exposure darks are also allowed.

    Returns:
        Metadata dict for matching dark, or None if no match found
    """
    exposure = float(light_metadata.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1))

    # Build filter criteria (without exposure)
    filter_criteria = {
        NORMALIZED_HEADER_TYPE: TYPE_MASTER_DARK,
        NORMALIZED_HEADER_CAMERA: light_metadata.get(NORMALIZED_HEADER_CAMERA),
        NORMALIZED_HEADER_GAIN: light_metadata.get(NORMALIZED_HEADER_GAIN),
        NORMALIZED_HEADER_OFFSET: light_metadata.get(NORMALIZED_HEADER_OFFSET),
        NORMALIZED_HEADER_SETTEMP: light_metadata.get(NORMALIZED_HEADER_SETTEMP),
        NORMALIZED_HEADER_READOUTMODE: light_metadata.get(
            NORMALIZED_HEADER_READOUTMODE
        ),
    }

    logger.debug(f"Searching for dark with criteria: {filter_criteria}")
    logger.debug(f"Target exposure: {exposure}s")

    # Search for all matching darks (any exposure)
    patterns = [rf".*\{ext}$" for ext in SUPPORTED_EXTENSIONS]
    darks = get_filtered_metadata(
        dirs=[str(library_dir)],
        filters=filter_criteria,
        profileFromPath=False,
        patterns=patterns,
        recursive=True,
    )

    if not darks:
        logger.debug("No darks found in library matching criteria")
        return None

    logger.debug(
        f"Found {len(darks)} darks in library with matching camera/gain/offset/temp/readoutmode"
    )

    # Convert dict to list of metadata dicts
    darks_list = list(darks.values())

    # Log available exposures
    available_exposures = sorted(
        [float(d.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1)) for d in darks_list]
    )
    logger.debug(f"Available dark exposures: {available_exposures}")

    # Try exact exposure match first
    exact_matches = [
        d
        for d in darks_list
        if float(d.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1)) == exposure
    ]

    if exact_matches:
        if len(exact_matches) > 1:
            logger.warning(
                f"Found {len(exact_matches)} matching darks for exposure {exposure}s, "
                f"using first match"
            )
        logger.debug(f"Found exact dark exposure match: {exposure}s")
        return exact_matches[0]

    # No exact match - check if bias frames are allowed
    if not allow_bias:
        logger.debug(
            f"No exact exposure match for {exposure}s and bias frames not allowed"
        )
        return None

    logger.debug(f"No exact exposure match for {exposure}s, looking for shorter dark")

    # No exact match - find longest dark exposure < light exposure
    shorter_darks = [
        d
        for d in darks_list
        if float(d.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1)) < exposure
    ]

    if shorter_darks:
        # Sort by exposure time and get the longest
        shorter_darks.sort(
            key=lambda d: float(d.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1)),
            reverse=True,
        )
        best_dark = shorter_darks[0]
        best_exposure = float(best_dark.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1))
        logger.debug(
            f"Found shorter dark exposure: {best_exposure}s "
            f"for light exposure: {exposure}s (will require bias)"
        )
        return best_dark

    logger.debug(
        f"No suitable dark found for exposure {exposure}s (all available darks have longer exposures)"
    )
    return None


def find_matching_bias(
    library_dir: Path,
    light_metadata: Dict[str, str],
) -> Optional[Dict[str, str]]:
    """
    Find matching bias frame for a light frame.

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame

    Returns:
        Metadata dict for matching bias, or None if no match found
    """
    filter_criteria = {
        NORMALIZED_HEADER_TYPE: TYPE_MASTER_BIAS,
        NORMALIZED_HEADER_CAMERA: light_metadata.get(NORMALIZED_HEADER_CAMERA),
        NORMALIZED_HEADER_GAIN: light_metadata.get(NORMALIZED_HEADER_GAIN),
        NORMALIZED_HEADER_OFFSET: light_metadata.get(NORMALIZED_HEADER_OFFSET),
        NORMALIZED_HEADER_SETTEMP: light_metadata.get(NORMALIZED_HEADER_SETTEMP),
        NORMALIZED_HEADER_READOUTMODE: light_metadata.get(
            NORMALIZED_HEADER_READOUTMODE
        ),
    }

    logger.debug(f"Searching for bias with criteria: {filter_criteria}")

    patterns = [rf".*\{ext}$" for ext in SUPPORTED_EXTENSIONS]
    biases = get_filtered_metadata(
        dirs=[str(library_dir)],
        filters=filter_criteria,
        profileFromPath=False,
        patterns=patterns,
        recursive=True,
    )

    if biases:
        # Convert dict to list of metadata dicts
        biases_list = list(biases.values())
        if len(biases_list) > 1:
            logger.warning(
                f"Found {len(biases_list)} matching bias frames, using first match"
            )
        logger.debug("Found matching bias")
        return biases_list[0]

    logger.debug("No bias found in library matching criteria")
    return None


def find_matching_flat(
    library_dir: Path,
    light_metadata: Dict[str, str],
) -> Optional[Dict[str, str]]:
    """
    Find matching flat frame for a light frame.

    DATE must match exactly.

    TODO: Support selecting older flats when exact date match not found
    This would scan DATE subdirectories < light frame date and pick the most recent

    TODO: Support selecting newer flats when exact date match not found
    This would scan DATE subdirectories > light frame date and pick the oldest

    TODO: Add configuration option for flat date tolerance (e.g., Â±7 days)

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame

    Returns:
        Metadata dict for matching flat, or None if no match found
    """
    filter_criteria = {
        NORMALIZED_HEADER_TYPE: TYPE_MASTER_FLAT,
        NORMALIZED_HEADER_CAMERA: light_metadata.get(NORMALIZED_HEADER_CAMERA),
        NORMALIZED_HEADER_OPTIC: light_metadata.get(NORMALIZED_HEADER_OPTIC),
        NORMALIZED_HEADER_FILTER: light_metadata.get(NORMALIZED_HEADER_FILTER),
        NORMALIZED_HEADER_GAIN: light_metadata.get(NORMALIZED_HEADER_GAIN),
        NORMALIZED_HEADER_OFFSET: light_metadata.get(NORMALIZED_HEADER_OFFSET),
        NORMALIZED_HEADER_SETTEMP: light_metadata.get(NORMALIZED_HEADER_SETTEMP),
        NORMALIZED_HEADER_READOUTMODE: light_metadata.get(
            NORMALIZED_HEADER_READOUTMODE
        ),
        NORMALIZED_HEADER_FOCALLEN: light_metadata.get(NORMALIZED_HEADER_FOCALLEN),
        NORMALIZED_HEADER_DATE: light_metadata.get(
            NORMALIZED_HEADER_DATE
        ),  # Exact match required
    }

    logger.debug(f"Searching for flat with criteria: {filter_criteria}")

    patterns = [rf".*\{ext}$" for ext in SUPPORTED_EXTENSIONS]
    flats = get_filtered_metadata(
        dirs=[str(library_dir)],
        filters=filter_criteria,
        profileFromPath=False,
        patterns=patterns,
        recursive=True,
    )

    if flats:
        # Convert dict to list of metadata dicts
        flats_list = list(flats.values())
        if len(flats_list) > 1:
            logger.warning(
                f"Found {len(flats_list)} matching flats for date {light_metadata.get(NORMALIZED_HEADER_DATE)} "
                f"and filter {light_metadata.get(NORMALIZED_HEADER_FILTER)}, using first match"
            )
        logger.debug("Found matching flat")
        return flats_list[0]

    logger.debug(
        f"No flat found in library matching criteria "
        f"(date={light_metadata.get(NORMALIZED_HEADER_DATE)}, "
        f"filter={light_metadata.get(NORMALIZED_HEADER_FILTER)})"
    )
    return None


def determine_required_masters(
    library_dir: Path,
    light_metadata: Dict[str, str],
    allow_bias: bool = False,
) -> Dict[str, Optional[Dict[str, str]]]:
    """
    Determine which master frames are required for a light frame.

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame
        allow_bias: If False, only exact exposure match darks are allowed.
                   If True, shorter exposure darks with bias are allowed.

    Returns:
        Dictionary with keys:
        - TYPE_MASTER_DARK: Dark metadata dict or None
        - TYPE_MASTER_BIAS: Bias metadata dict or None
        - TYPE_MASTER_FLAT: Flat metadata dict or None
    """
    logger.debug("Determining required masters for light frame")

    dark = find_matching_dark(library_dir, light_metadata, allow_bias=allow_bias)
    bias = None
    flat = find_matching_flat(library_dir, light_metadata)

    # Only look for bias if dark exposure != light exposure
    if dark:
        dark_exposure = float(dark.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1))
        light_exposure = float(
            light_metadata.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1)
        )

        if dark_exposure < light_exposure:
            # Shorter dark - need bias
            logger.debug(
                f"Dark exposure ({dark_exposure}s) < light exposure ({light_exposure}s), bias required"
            )
            bias = find_matching_bias(library_dir, light_metadata)
            if not bias:
                # No bias found - cannot use this dark
                logger.warning(
                    f"Found shorter dark ({dark_exposure}s) but no matching bias "
                    f"for light exposure ({light_exposure}s) - cannot use dark"
                )
                dark = None
        else:
            logger.debug(
                f"Dark exposure ({dark_exposure}s) matches light exposure, no bias required"
            )

    return {
        TYPE_MASTER_DARK: dark,
        TYPE_MASTER_BIAS: bias,
        TYPE_MASTER_FLAT: flat,
    }
