"""
Library search and matching logic for master calibration frames

CRITICAL: Library Search Parameter - profileFromPath=False
-----------------------------------------------------------
All library searches MUST use profileFromPath=False when calling ap_common
calibration utilities (find_darks_util, find_flats_util, find_bias_util).

Why:
----
Library directory structure uses bare equipment names without KEY_VALUE encoding:
    _Library/MASTER FLAT/{camera}/{optic}/DATE_{date}/masterFlat_...xisf
                         ^^^^^^^^  ^^^^^^
                         Not encoded as CAMERA_xxx or OPTIC_xxx

When profileFromPath=True (default), ap_common attempts to extract metadata from
path structure using KEY_VALUE pattern matching. This works for blink directories
(e.g., "C8E@f10.0+ZWO ASI2600MM Pro") but FAILS for library directories because:
1. Bare directory names (ATR585M, SQA55) are not recognized as KEY_VALUE pairs
2. Camera and optic metadata are missing from extracted profile
3. Matching fails even when correct calibration frames exist

Solution:
---------
Use profileFromPath=False to read actual FITS keywords from files instead of
parsing directory structure. This ensures:
- Camera, optic, filter, gain, offset, etc. come from file headers
- DATE from path (DATE_2026-02-07) still overrides file headers
- Matching works correctly with library structure

Reference:
----------
See ap_common/calibration.py lines 86-87:
    # IMPORTANT: profileFromPath only works with blink/data directory structure
    # For library searches, it should typically be False to read actual file headers

Regression Tests:
-----------------
See tests/test_matching.py::TestLibraryProfileFromPath for regression tests that
verify profileFromPath=False is passed correctly. To verify the tests catch the
regression, temporarily remove profileFromPath=False and run:
    pytest tests/test_matching.py::TestLibraryProfileFromPath -v

Generated By: Claude Code (Claude Sonnet 4.5)
"""

from typing import Dict, Optional
from pathlib import Path
import logging

from ap_common.calibration import (
    find_matching_darks as find_darks_util,
    find_matching_flats as find_flats_util,
    find_matching_bias as find_bias_util,
)
from ap_common.constants import (
    TYPE_MASTER_DARK,
    TYPE_MASTER_FLAT,
    TYPE_MASTER_BIAS,
    NORMALIZED_HEADER_CAMERA,
    NORMALIZED_HEADER_GAIN,
    NORMALIZED_HEADER_OFFSET,
    NORMALIZED_HEADER_SETTEMP,
    NORMALIZED_HEADER_READOUTMODE,
    NORMALIZED_HEADER_EXPOSURESECONDS,
    NORMALIZED_HEADER_DATE,
    NORMALIZED_HEADER_FILTER,
    NORMALIZED_HEADER_OPTIC,
    NORMALIZED_HEADER_FOCALLEN,
)

logger = logging.getLogger(__name__)


def find_matching_dark(
    library_dir: Path,
    light_metadata: Dict[str, str],
    scale_darks: bool = False,
) -> Optional[Dict[str, str]]:
    """
    Find matching dark frame for a light frame.

    Priority:
    1. Exact exposure match
    2. If scale_darks=True and no exact match: longest dark < light

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame
        scale_darks: If False, only exact exposure match darks are returned.
                    If True, shorter exposure darks are also allowed.

    Returns:
        Metadata dict for matching dark, or None if no match found
    """
    # Use ap_common utility to find matching darks
    matches = find_darks_util(
        library_dir,
        light_metadata,
        match_fields=[
            NORMALIZED_HEADER_CAMERA,
            NORMALIZED_HEADER_GAIN,
            NORMALIZED_HEADER_OFFSET,
            NORMALIZED_HEADER_SETTEMP,
            NORMALIZED_HEADER_READOUTMODE,
        ],
        allow_shorter_exposure=scale_darks,
        recursive=True,
        profileFromPath=False,  # Read file headers, not path structure
        printStatus=False,  # No progress output for library search
    )

    # Return first match (utility already sorts by exposure, longest first)
    if matches:
        exposure = float(light_metadata.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1))
        best_dark = matches[0]
        best_exposure = float(best_dark.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1))

        if len(matches) > 1:
            logger.warning(
                f"Found {len(matches)} matching darks for exposure {exposure}s, "
                f"using longest match: {best_exposure}s"
            )

        if best_exposure == exposure:
            logger.debug(f"Found exact dark exposure match: {exposure}s")
        elif best_exposure < exposure:
            logger.debug(
                f"Found shorter dark exposure: {best_exposure}s "
                f"for light exposure: {exposure}s (will require bias)"
            )

        return best_dark

    return None


def find_matching_bias(
    library_dir: Path,
    light_metadata: Dict[str, str],
) -> Optional[Dict[str, str]]:
    """
    Find matching bias frame for a light frame.

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame

    Returns:
        Metadata dict for matching bias, or None if no match found
    """
    # Use ap_common utility to find matching bias frames
    matches = find_bias_util(
        library_dir,
        light_metadata,
        match_fields=[
            NORMALIZED_HEADER_CAMERA,
            NORMALIZED_HEADER_GAIN,
            NORMALIZED_HEADER_OFFSET,
            NORMALIZED_HEADER_SETTEMP,
            NORMALIZED_HEADER_READOUTMODE,
        ],
        recursive=True,
        profileFromPath=False,  # Read file headers, not path structure
        printStatus=False,  # No progress output for library search
    )

    # Return first match
    if matches:
        if len(matches) > 1:
            logger.warning(
                f"Found {len(matches)} matching bias frames, using first match"
            )
        logger.debug("Found matching bias")
        return matches[0]

    logger.debug("No bias found in library matching criteria")
    return None


def find_matching_flat(
    library_dir: Path,
    light_metadata: Dict[str, str],
) -> Optional[Dict[str, str]]:
    """
    Find matching flat frame for a light frame.

    DATE must match exactly. For flexible date matching, see
    find_candidate_flat_dates() and the --flat-state CLI option.

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame

    Returns:
        Metadata dict for matching flat, or None if no match found
    """
    # Use ap_common utility to find matching flats
    # DATE must match exactly for library search
    matches = find_flats_util(
        library_dir,
        light_metadata,
        match_fields=[
            NORMALIZED_HEADER_CAMERA,
            NORMALIZED_HEADER_OPTIC,
            NORMALIZED_HEADER_FILTER,
            NORMALIZED_HEADER_GAIN,
            NORMALIZED_HEADER_OFFSET,
            NORMALIZED_HEADER_SETTEMP,
            NORMALIZED_HEADER_READOUTMODE,
            NORMALIZED_HEADER_FOCALLEN,
            NORMALIZED_HEADER_DATE,  # Exact match required for library
        ],
        recursive=True,
        profileFromPath=False,  # Read file headers, not path structure
        printStatus=False,  # No progress output for library search
    )

    # Return first match
    if matches:
        if len(matches) > 1:
            date = light_metadata.get(NORMALIZED_HEADER_DATE)
            filt = light_metadata.get(NORMALIZED_HEADER_FILTER)
            logger.warning(
                f"Found {len(matches)} matching flats for "
                f"date {date} and filter {filt}, "
                f"using first match"
            )
        logger.debug("Found matching flat")
        return matches[0]

    logger.debug(
        f"No flat found in library matching criteria "
        f"(date={light_metadata.get(NORMALIZED_HEADER_DATE)}, "
        f"filter={light_metadata.get(NORMALIZED_HEADER_FILTER)})"
    )
    return None


def find_candidate_flat_dates(
    library_dir: Path,
    light_metadata: Dict[str, str],
    cutoff_date: Optional[str] = None,
) -> Dict[str, Dict[str, str]]:
    """
    Find all candidate flat dates matching equipment criteria (ignoring date).

    Searches the library for flats matching camera, optic, filter, gain,
    offset, settemp, readoutmode, focallen - but NOT date. Returns a dict
    mapping date string to the flat metadata for that date.

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame
        cutoff_date: If set, exclude flats older than this date (YYYY-MM-DD)

    Returns:
        Dictionary mapping date string (YYYY-MM-DD) to flat metadata dict.
        Only includes dates >= cutoff_date if cutoff is set.
    """
    # Search without date constraint
    matches = find_flats_util(
        library_dir,
        light_metadata,
        match_fields=[
            NORMALIZED_HEADER_CAMERA,
            NORMALIZED_HEADER_OPTIC,
            NORMALIZED_HEADER_FILTER,
            NORMALIZED_HEADER_GAIN,
            NORMALIZED_HEADER_OFFSET,
            NORMALIZED_HEADER_SETTEMP,
            NORMALIZED_HEADER_READOUTMODE,
            NORMALIZED_HEADER_FOCALLEN,
            # NOTE: date intentionally omitted for flexible matching
        ],
        recursive=True,
        profileFromPath=False,  # Read file headers, not path structure
        printStatus=False,  # No progress output for library search
    )

    if not matches:
        logger.debug("No candidate flats found in library")
        return {}

    # Group by date, keeping first match per date
    by_date: Dict[str, Dict[str, str]] = {}
    for flat in matches:
        flat_date = flat.get(NORMALIZED_HEADER_DATE)
        if not flat_date:
            continue
        if flat_date not in by_date:
            by_date[flat_date] = flat

    # Filter by cutoff
    if cutoff_date:
        by_date = {d: m for d, m in by_date.items() if d >= cutoff_date}

    logger.debug(
        f"Found {len(by_date)} candidate flat dates " f"(cutoff={cutoff_date})"
    )
    return by_date


def find_flat_for_date(
    library_dir: Path,
    light_metadata: Dict[str, str],
    target_date: str,
) -> Optional[Dict[str, str]]:
    """
    Find a matching flat frame for a specific date.

    Like find_matching_flat, but uses the specified date instead of the
    light frame's date.

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame
        target_date: Date to search for (YYYY-MM-DD)

    Returns:
        Metadata dict for matching flat, or None if no match found
    """
    # Create modified metadata with target date
    search_metadata = dict(light_metadata)
    search_metadata[NORMALIZED_HEADER_DATE] = target_date

    matches = find_flats_util(
        library_dir,
        search_metadata,
        match_fields=[
            NORMALIZED_HEADER_CAMERA,
            NORMALIZED_HEADER_OPTIC,
            NORMALIZED_HEADER_FILTER,
            NORMALIZED_HEADER_GAIN,
            NORMALIZED_HEADER_OFFSET,
            NORMALIZED_HEADER_SETTEMP,
            NORMALIZED_HEADER_READOUTMODE,
            NORMALIZED_HEADER_FOCALLEN,
            NORMALIZED_HEADER_DATE,
        ],
        recursive=True,
        profileFromPath=False,  # Read file headers, not path structure
        printStatus=False,  # No progress output for library search
    )

    if matches:
        logger.debug(f"Found flat for date {target_date}")
        return matches[0]

    logger.debug(f"No flat found for date {target_date}")
    return None


def determine_required_masters(
    library_dir: Path,
    light_metadata: Dict[str, str],
    scale_darks: bool = False,
) -> Dict[str, Optional[Dict[str, str]]]:
    """
    Determine which master frames are required for a light frame.

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame
        scale_darks: If False, only exact exposure match darks are allowed.
                    If True, shorter exposure darks with bias are allowed.

    Returns:
        Dictionary with keys:
        - TYPE_MASTER_DARK: Dark metadata dict or None
        - TYPE_MASTER_BIAS: Bias metadata dict or None
        - TYPE_MASTER_FLAT: Flat metadata dict or None
    """
    logger.debug("Determining required masters for light frame")

    dark = find_matching_dark(library_dir, light_metadata, scale_darks=scale_darks)
    bias = None
    flat = find_matching_flat(library_dir, light_metadata)

    # Only look for bias if dark exposure != light exposure
    if dark:
        dark_exposure = float(dark.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1))
        light_exposure = float(
            light_metadata.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1)
        )

        if dark_exposure < light_exposure:
            # Shorter dark - need bias
            logger.debug(
                f"Dark exposure ({dark_exposure}s) < light "
                f"exposure ({light_exposure}s), bias required"
            )
            bias = find_matching_bias(library_dir, light_metadata)
            if not bias:
                # No bias found - cannot use this dark
                logger.warning(
                    f"Found shorter dark ({dark_exposure}s) but no matching bias "
                    f"for light exposure ({light_exposure}s) - cannot use dark"
                )
                dark = None
        else:
            logger.debug(
                f"Dark exposure ({dark_exposure}s) matches "
                f"light exposure, no bias required"
            )

    return {
        TYPE_MASTER_DARK: dark,
        TYPE_MASTER_BIAS: bias,
        TYPE_MASTER_FLAT: flat,
    }
