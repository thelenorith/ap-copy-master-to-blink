"""
Library search and matching logic for master calibration frames

Generated By: Claude Code (Claude Sonnet 4.5)
"""

from typing import Dict, List, Optional
from pathlib import Path
import logging

from ap_common import get_filtered_metadata
from ap_common.constants import (
    TYPE_MASTER_DARK,
    TYPE_MASTER_FLAT,
    TYPE_MASTER_BIAS,
    NORMALIZED_HEADER_TYPE,
    NORMALIZED_HEADER_CAMERA,
    NORMALIZED_HEADER_GAIN,
    NORMALIZED_HEADER_OFFSET,
    NORMALIZED_HEADER_SETTEMP,
    NORMALIZED_HEADER_READOUTMODE,
    NORMALIZED_HEADER_EXPOSURESECONDS,
    NORMALIZED_HEADER_DATE,
    NORMALIZED_HEADER_FILTER,
    NORMALIZED_HEADER_OPTIC,
    NORMALIZED_HEADER_FOCALLEN,
)

logger = logging.getLogger(__name__)


def find_matching_dark(
    library_dir: Path,
    light_metadata: Dict[str, str],
) -> Optional[Dict[str, str]]:
    """
    Find matching dark frame for a light frame.

    Priority:
    1. Exact exposure match
    2. If no exact match: Find longest dark exposure < light exposure

    Note: Caller is responsible for determining if bias is needed when
    dark exposure < light exposure.

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame

    Returns:
        Metadata dict for matching dark, or None if no match found
    """
    exposure = float(light_metadata.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1))

    # Build filter criteria (without exposure)
    filter_criteria = {
        NORMALIZED_HEADER_TYPE: TYPE_MASTER_DARK,
        NORMALIZED_HEADER_CAMERA: light_metadata.get(NORMALIZED_HEADER_CAMERA),
        NORMALIZED_HEADER_GAIN: light_metadata.get(NORMALIZED_HEADER_GAIN),
        NORMALIZED_HEADER_OFFSET: light_metadata.get(NORMALIZED_HEADER_OFFSET),
        NORMALIZED_HEADER_SETTEMP: light_metadata.get(NORMALIZED_HEADER_SETTEMP),
        NORMALIZED_HEADER_READOUTMODE: light_metadata.get(
            NORMALIZED_HEADER_READOUTMODE
        ),
    }

    # Search for all matching darks (any exposure)
    darks = get_filtered_metadata(library_dir, filter_criteria)

    if not darks:
        logger.debug(f"No matching darks found for criteria: {filter_criteria}")
        return None

    # Try exact exposure match first
    exact_matches = [
        d
        for d in darks
        if float(d.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1)) == exposure
    ]

    if exact_matches:
        if len(exact_matches) > 1:
            logger.warning(
                f"Found {len(exact_matches)} matching darks for exposure {exposure}s, "
                f"using first match"
            )
        logger.debug(f"Found exact dark exposure match: {exposure}s")
        return exact_matches[0]

    # No exact match - find longest dark exposure < light exposure
    shorter_darks = [
        d
        for d in darks
        if float(d.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1)) < exposure
    ]

    if shorter_darks:
        # Sort by exposure time and get the longest
        shorter_darks.sort(
            key=lambda d: float(d.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1)),
            reverse=True,
        )
        best_dark = shorter_darks[0]
        logger.debug(
            f"Found shorter dark exposure: {best_dark.get(NORMALIZED_HEADER_EXPOSURESECONDS)}s "
            f"for light exposure: {exposure}s"
        )
        return best_dark

    logger.debug(f"No suitable dark found for exposure {exposure}s")
    return None


def find_matching_bias(
    library_dir: Path,
    light_metadata: Dict[str, str],
) -> Optional[Dict[str, str]]:
    """
    Find matching bias frame for a light frame.

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame

    Returns:
        Metadata dict for matching bias, or None if no match found
    """
    filter_criteria = {
        NORMALIZED_HEADER_TYPE: TYPE_MASTER_BIAS,
        NORMALIZED_HEADER_CAMERA: light_metadata.get(NORMALIZED_HEADER_CAMERA),
        NORMALIZED_HEADER_GAIN: light_metadata.get(NORMALIZED_HEADER_GAIN),
        NORMALIZED_HEADER_OFFSET: light_metadata.get(NORMALIZED_HEADER_OFFSET),
        NORMALIZED_HEADER_SETTEMP: light_metadata.get(NORMALIZED_HEADER_SETTEMP),
        NORMALIZED_HEADER_READOUTMODE: light_metadata.get(
            NORMALIZED_HEADER_READOUTMODE
        ),
    }

    biases = get_filtered_metadata(library_dir, filter_criteria)

    if biases:
        if len(biases) > 1:
            logger.warning(
                f"Found {len(biases)} matching bias frames, using first match"
            )
        logger.debug(f"Found matching bias for criteria: {filter_criteria}")
        return biases[0]

    logger.debug(f"No matching bias found for criteria: {filter_criteria}")
    return None


def find_matching_flat(
    library_dir: Path,
    light_metadata: Dict[str, str],
) -> Optional[Dict[str, str]]:
    """
    Find matching flat frame for a light frame.

    DATE must match exactly.

    TODO: Support selecting older flats when exact date match not found
    This would scan DATE subdirectories < light frame date and pick the most recent

    TODO: Support selecting newer flats when exact date match not found
    This would scan DATE subdirectories > light frame date and pick the oldest

    TODO: Add configuration option for flat date tolerance (e.g., Â±7 days)

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame

    Returns:
        Metadata dict for matching flat, or None if no match found
    """
    filter_criteria = {
        NORMALIZED_HEADER_TYPE: TYPE_MASTER_FLAT,
        NORMALIZED_HEADER_CAMERA: light_metadata.get(NORMALIZED_HEADER_CAMERA),
        NORMALIZED_HEADER_OPTIC: light_metadata.get(NORMALIZED_HEADER_OPTIC),
        NORMALIZED_HEADER_FILTER: light_metadata.get(NORMALIZED_HEADER_FILTER),
        NORMALIZED_HEADER_GAIN: light_metadata.get(NORMALIZED_HEADER_GAIN),
        NORMALIZED_HEADER_OFFSET: light_metadata.get(NORMALIZED_HEADER_OFFSET),
        NORMALIZED_HEADER_SETTEMP: light_metadata.get(NORMALIZED_HEADER_SETTEMP),
        NORMALIZED_HEADER_READOUTMODE: light_metadata.get(
            NORMALIZED_HEADER_READOUTMODE
        ),
        NORMALIZED_HEADER_FOCALLEN: light_metadata.get(NORMALIZED_HEADER_FOCALLEN),
        NORMALIZED_HEADER_DATE: light_metadata.get(
            NORMALIZED_HEADER_DATE
        ),  # Exact match required
    }

    flats = get_filtered_metadata(library_dir, filter_criteria)

    if flats:
        if len(flats) > 1:
            logger.warning(
                f"Found {len(flats)} matching flats for date {light_metadata.get(NORMALIZED_HEADER_DATE)} "
                f"and filter {light_metadata.get(NORMALIZED_HEADER_FILTER)}, using first match"
            )
        logger.debug(
            f"Found matching flat for date: {light_metadata.get(NORMALIZED_HEADER_DATE)}"
        )
        return flats[0]

    logger.debug(
        f"No matching flat found for date: {light_metadata.get(NORMALIZED_HEADER_DATE)} "
        f"and filter: {light_metadata.get(NORMALIZED_HEADER_FILTER)}"
    )
    return None


def determine_required_masters(
    library_dir: Path,
    light_metadata: Dict[str, str],
) -> Dict[str, Optional[Dict[str, str]]]:
    """
    Determine which master frames are required for a light frame.

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame

    Returns:
        Dictionary with keys:
        - TYPE_MASTER_DARK: Dark metadata dict or None
        - TYPE_MASTER_BIAS: Bias metadata dict or None
        - TYPE_MASTER_FLAT: Flat metadata dict or None
    """
    dark = find_matching_dark(library_dir, light_metadata)
    bias = None
    flat = find_matching_flat(library_dir, light_metadata)

    # Only look for bias if dark exposure != light exposure
    if dark:
        dark_exposure = float(dark.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1))
        light_exposure = float(
            light_metadata.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1)
        )

        if dark_exposure < light_exposure:
            # Shorter dark - need bias
            bias = find_matching_bias(library_dir, light_metadata)
            if not bias:
                # No bias found - cannot use this dark
                logger.warning(
                    f"Found shorter dark ({dark_exposure}s) but no matching bias "
                    f"for light exposure ({light_exposure}s) - cannot use dark"
                )
                dark = None

    return {
        TYPE_MASTER_DARK: dark,
        TYPE_MASTER_BIAS: bias,
        TYPE_MASTER_FLAT: flat,
    }
